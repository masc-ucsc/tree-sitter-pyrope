
// Fetch Target Queue

let ftq = punch "ftq"  // punch does not create a new instance

reg pc
reg ftq_head:ftq.size

// Branch miss, the clear FTQ and start again
if flush_pc {
  pc = flush_pc
  ftq.flush()
  fast_tage.flush()
  sast_tage.flush()
}

// Do uBTB prediction (pure combinational)
let ubtb  = import "btb"

let ubtb_pc = ubtb.predict(pc)
if ubtb_pc? and !ftq.full {
  ftq.insert(ftq_head, ubtb_pc)
  ftq_head += 1
}

// Fast TAGE+BTB predictor (1 or 2 predictions per cycle)
let ftage_pc   =# fast_tage.predict(pc)
ftage_ftq_head =# repipe ftq_head to stage_pc

if ftage_pc? {
  ftq.fix(ftage_ftq_head)
  for f in ftage_pc {
    ftq.append(ftage_ftq_head+i, ftage_pc[i])
  }
  ftq_head = ftage_ftq_head + ftage_ftq_head.size

  fast_tage.flush()
}

// Slow TAGE+BTB predictor (1 predictions per cycle)
let stage_pc    =# slow_tage.predict(pc)
stage_ftq_head  =# repipe ftq_head to stage_pc

if stage_pc? {
  ftq.fix(stage_ftq_head)
  ftq.append(stage_ftq_head+i, ftage_pc[i])
  ftq_head = stage_ftq_head + 1

  fast_tage.flush()
  slow_tage.flush()
}

pc = ftq.head_pc

