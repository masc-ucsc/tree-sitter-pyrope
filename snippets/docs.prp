    var result = 0
    if some_opcode {
      result = do_division(a,b)
    }else{
      result = do_multiplication(a,b)
    }

    var result = 0
    var result1 = do_division(a,b)
    var result2 = do_multiplication(a,b)
    if some_opcode {
      result = result1
    }else{
      result = result2
    }

    var c = mul(a,b)
    assert c == a * b // assert fails!!

    var c = mul(a,b)
    assert c == a#[-1] * b#[-1] // read last cycle #[-1] a and b











    // Do not use non-blocking
    counter = counter + 1  // blocking assignment
    tmp     = counter + 2  // blocking assignment
    assert tmp == (counter+1) // this never fails







test "my first test" {
  puts "hello world"
}



    var gcd = proc (a:uint,b:uint)->(reg x:uint) {
      x = a
      reg y = b

      while y!=0 #> {
        if x > y { 
          x -= y 
        }else{ 
          y -= x 
        }
      }
    }

    for a in 1..=100 {
      for b in 1..=100 {
        test "check.gcd({},{})",a,b {
          let z =#[..] gcd(a,b)

          waitfor z?

          assert z == __my_cpp_gcd(v1=a, v2=b)
        }
      }
    }







// comment
a = 3 // another comment

0xF_a_0 // 4000 in hexa. Underscores have no meaning
0b1100  // 12 in binary
0sb1110 // -2 in binary (sb signed binary)
33      // 33 in decimal
0o111   // 73 in octal
0111    // 111 in decimal (some languages use octal here)

assert 1K == 1024
assert 1M == 1024*1024
assert 1G == 1024*1024*1024
assert 1T == 1024*1024*1024*1024

0b?             // 0 or 1 in decimal
0sb?            // 0 or -1 in decimal
0b?0            // 0 or 2 in decimal
0sb0?0          // 0 or 2 in decimal

a = "hello \n newline"
b = 'simpler here'

let num       = 2
let color     = "blue"
let extension = "s"

let txt = "I have {num:d} {color} potato{extension}"
cassert txt == "I have 2 blue potatos"

var a:string = "127"
var b:int    = a     // same as var b = int(a)
var c:string = b     // same as var c = string(b)
assert a == c
assert b == 0x7F

var (a,b,c,d) = _
a = 1
  + 3           // 1st stmt
(b,c) = (1,3)   // 2nd stmt
cassert a == 4 and b == 1 and c == 3

d = 1 +         // OK, but not formatted to style
    3

`foo is . strange!\nidentifier` = 4
`for` = 3
cassert `for`+1 == `foo is . strange!\nidentifier`

a = 1 ; b = 2

a = 1
puts "Hello a is {}", a

// src/file1.prp
puts(priority=2, " world")

// src/file2.prp
print(priority=1, "hello")

var f = fun(a,b) { a + b }

var a = fcall() + 1               // OK
var x = pcall() + a               // OK, proc combined with variable read
var b = fcall(a) + 10 + pcall(a)  // OK

var a = {var d=3 ; last d+1} + 100 // OK
assert a == (3+1+100)
assert a == {3+1+100}  // same, expression evaluated as 104 and returned














    var r1 = fcall1()
    r1  = fcall2() unless r1

    var r2 = fcall1()
    r2  = fcall2() when r2

    var r3 = fcall1()
    r3 += fcall2()

    var r1 = fcall1() or_else fcall2()


    var r2 = fcall1() and_then fcall2()


    var r3 = fcall1()
    r3 += fcall2()


var b = 3
b  = 5        // OK
b += 1        // OK

let cu3 = if runtime { 3 }else{ 5 }

let d = "hello"  // OK

var e = _        // OK, no type or default value, just scope declaration
e:u32 = 33       // OK

var Foo = 33     // compiler error, 'let Foo = 33'
Foo  = 33        // compiler error, `Foo` already declared as immutable

var tup = nil

if cond::[comptime] {
  tup = (a=1,b=2)
}else{
  tup = (a=1,b:u4=3,c=3)
}

cassert tup.a == 1
cassert cond implies tup.b==2
cassert !cond implies tup.b==3

var A_xxx = something             // comptime
var A_yyy::[comptime] = something // also comptime, redundant but legal

var b = (f1=3,f2=4) // b is named and ordered
var c = (1,d=4)     // c is ordered and unnamed (some entries are not named)

var d = (1,2,3,4)     // array or tuple
assert d == [1,2,3,4] // the [] also check that all the fields have same type


var a = (
  ,r1 = (b=1,c=2)
  ,r2 = (3,4)
)
// tuple position is from left to right
cassert a.r1 == (1,2) and a.r2 == (3,4)
cassert a.0  == (1,2) and a[1] == (3,4)

// different ways to access the same field
cassert a.r1.c    == 2
cassert a['r1'].c == 2
cassert a.r1.1    == 2
cassert a.r1[1]   == 2
cassert a[0][1]   == 2
cassert a[0]['c'] == 2
cassert a['r1.c'] == 2
cassert a['r1.1'] == 2
cassert a['0.c']  == 2
cassert a['0.1']  == 2
cassert a.0.c     == 2
cassert a.0.1     == 2

var a = (foo = 3)
cassert a has 'foo'
cassert !(a has 'bar')
cassert a !has 'bar' // "has no" is the opposite of "has"
cassert a has 0
cassert a !has 1
cassert a !has 1

var val = 4
var x = (
  ,field1=1           // field1 with implicit type and 1 value
  ,field2:string = _  // field2 with explicit type and "" default value
  ,field3:int = 3     // field3 with explicit type and 3 value
  ,val                // unnamed field with value `val` (4)
)

var x=100

var tup1 = ('x',y=4)
var tup2 = (x,y=4)

cassert tup1[0] == 'x'
cassert tup2[0] == 100

let aa = 3
let a = enum(aa,b=3)
cassert a==b

cassert x.[size] == x.['size']

let zz= "size"
cassert x.[...zz] == x.[size]

var a = (1,2)   // tuple of 2 entries, 1 and 2
var b = (1)     // tuple of 1 entry, 1
var c = 1       // tuple of 1 entry, 1
var d = (,,1,,) // tuple of 1 entry, 1
cassert a.0 == b.0 == c.0 == d.0
cassert a!=b
cassert b == c == d

var c=(x=1,let b = 2, var d=3)
c.x   = 3  // OK
c.d   = 30 // OK, d was already mutable type

let d=(x=1, let y=2, var z=3)
d.x   = 2  // OK

var e:d = _
assert e.x==1 and e.y==2 and e.z==3
e.x = 30   // OK
e.z = 30   // OK

var b = 100
var a = (b:u8, b, b:u8 = _, let c=4) // a.0 and a.1 are unnamed, a.2==a.b 
a.b = 200
assert a == (100, 100, 200, 4)

var f = (b=3, let e=5)
f.b = 4                 // OK

let x = (1,2)
var y = (1, let _ = 3)  // 2nd field is unnamed (only let allows that)
y[0] = 100              // OK

var a=(a=1,b=2)
let b=(c=3)

let ccat1 = a ++ b
assert ccat1 == (a=1,b=2,c=3)
assert ccat1 == (1,2,3)

var ccat2 = a                // mutable tuple
a = a ++ (b=20)
assert ccat2 == (a=1,b=(2,20),c=3)
assert ccat2 == (1,(2,20),3)

var join1 = (...a,...b)
assert join1 == (a=1,b=2,c=3)
assert join1 == (1,2,3)


assert(((1,a=2,c=3) ++ (a=20,33,c=30,4)) == (1,a=(2,20),c=(3,30),33,4))

let x = (first=(second=3))

assert x.first.second == 3
assert x.first        == 3
assert x              == 3
assert x.0.second     == 3
assert x.first.0      == 3
assert x.0            == 3

var bund1 = (0,1,2,3,4) // ordered and can be used as an array

var bund2 = (bund1,bund1,((10,20),30))
assert bund2[0][1] == 1
assert bund2[1][1] == 1
assert bund2[2][0] == (10,20)
assert bund2[2][0][1] == 20
assert bund2[2][1] == 30

var array = (0,1,2)       // size 3, not 4
var index = 2
if runtime {
  index = 4
}
// Index can be 2 or 4


var res2 = 0sb?           // Possible code to be compatible with Verilog
if index<3 {
  res = array[index]      // OK
}

var x = (
  ,ff = 1
)

var y = (
  ,ff = 1
  ,ff ++= 2
  ,zz ++= 3
)
assert y == (ff=(1,2),zz=3)

fcall 1,2         // same as: fcall(1,2)
b = xx[1,2]       // same as: xx[(1,2)]

for a in 1,2,3 {  // same as: for a in (1,2,3) {
  x = a
}
y = match z {    
  in 1,2 { 4 }    // same as: in (1,2) { 4 }
  else { 5 }
}
y2 = match var one=1 ; one ++ z {  // same as: y2 = match (1,z) {
  == (1,2) { 4 }
}

let addb = fun(a,b:u32)-> a:u32 { // same as: letaddb = fun(a,b:u32)->(a:u32)  
  a = a + b
}

var (a,b) = (2,3)
assert a==2 and b==3

var c = 1..=2      // OK
var (c,d) = (1,2)  // OK
assert c == 1 and d == 2

let c = 4
let (x,b) = (true, c:u3) // assign x=true, b=4 AND check that c is type u3

cassert x == true
cassert b == 4 

let b = "foo"
let c = 1
let test1     = enum(a=c,b)    // OK
let something = (b)            // OK
cassert something == "foo"
cassert test1.a != test1.b
cassert test1.a==1 and test1.b==2

let a = "field"
let c = (foo=4)
let my_other_enum = enum(...a,b=3,...c)
cassert my_other_enum.field != my_other_enum.b
cassert my_other_enum.b   == 3
cassert my_other_enum.foo == 4
cassert my_other_enum.foo != my_other_enum.b

let V3 = enum(
   ,a
   ,b
   ,c
)
cassert V3.a == 1
cassert V3.b == 2
cassert V3.c == 4

let V4 = enum(
   ,a
   ,b=5
   ,c
)
cassert V4.a == 0
cassert V4.b == 5
cassert V4.c == 6

let Animal = enum(
  ,bird  =(eagle, parrot)
  ,mammal=(rat  , human )
)

cassert Animal.bird.eagle != Animal.mammal
cassert Animal.bird != Animal.mammal.human
cassert Animal.bird == Animal.bird.parrot

cassert int(Animal.bird        ) == 0b000001
cassert int(Animal.bird.eagle  ) == 0b000011
cassert int(Animal.bird.parrot ) == 0b000101
cassert int(Animal.mammal      ) == 0b001000
cassert int(Animal.mammal.rat  ) == 0b011000
cassert int(Animal.mammal.human) == 0b101000

let V5=enum(
   ,a
   ,b=5
   ,c
)
cassert int(V5.a) == 0
cassert int(V5.b) == 5
cassert int(V5.c) == 6

let human_rat = Animal.mammal.rat | Animal.mammal.human  // union op

assert Animal.mammal      in human_rat
assert Animal.mammal.rat  in human_rat
assert Animal.bird       !in human_rat

let E3=enum(
  ,l1=(
    ,l1a
    ,l1b
    )
  ,l2
  )
cassert string(E3.l1.l1a) == "E3.l1.l1a"
cassert string(E3.l1) == "E3.l1"
cassert E3("l1.l2") == E3.l1.l2

    var a = 3
    {
      assert a == 3
      a = 33             // OK. assign 33
      a:int = 33         // OK, assign 33 and check that 'a' has type int
      let b = 4
    }

    var a = 3
    var x = 10
    let f1 = fun[a,x=a+1]() {
      assert a == 3
      let b = 4
      return b+3
    }
    assert f1() == 7
    assert x == 10

    let f2 = fun() {     // restrict scope
    }
    let f3 = fun[ff=a]() { // restrict scope
      assert ff == 3     // OK
    }

    var a = 3
    let r1 = (
      ,a = a+1           // same as var a = a+1
      ,c = {assert a == 3 and self.a==4; 50}
    )

    var r2 = (a=100, let c=(a=a+1, e=self.a+30))
    assert r2 == (a=100,c=(a=101, e=131))  // checks values not mutability
    r2.a = 33            // OK


var a:int         = _ // any value, no constrain
var b:unsigned    = _ // only positive values
var c:u13         = _ // only from 0 to 1<<13
var d:int(20..=30)= _ // only values from 20 to 30 (both included)
var d:int(-5..<6) = _ // only values from -5 to 6 (6 not included)
var e:int(-1,0)   = _ // 1 bit integer: -1 or 0

let b = true
let c = 3

if c!=0 { call(x) }  // OK

var d = b or false   // OK

let e = 0xfeed
if e@[3] {           // OK, bit extraction for single bit returns a boolean
  call(x)
}

assert 0 == (int(true)  + 1)  // explicity typecast
assert 1 == (int(false) + 1)  // explicity typecast
assert boolean(33) or false   // explicity typecast

let x = a and b

let a = (1,2,3)
assert a[0..] == (1,2,3)
assert a[1..] == (2,3)
assert a[..=1] == (1,2)
assert a[..<2] == (1,2)
assert a[1..<10] == (2,3)

let b = 0b0110_1001
assert b@[1..]        == 0b0110_100
assert b@[1..=-1]     == 0b0110_100
assert b@[1..=-2]     == 0b0110_100  // unsigned result from bit selector
assert b@sext[1..=-2] == 0sb110_100
assert b@[1..=-3]     == 0sb10_100
assert b@[1..<-3]     == 0b0_100
assert b@[0]          == false

let c = 1..=3
assert int(c) == 0b1110
assert range(0b01_1100) == 2..=4

assert (1,2,3) == tuple(1..=3)

assert   int(0..=10 step  2) == 0b101_0101_0101
assert tuple(0..=10 step  2) == ( 0,2,4,6,8,10)
assert tuple(10..=0 step -2) == (10,8,6,4,2, 0)
assert      (10..=0 step -2) == (10,8,6,4,2, 0)

assert -1..=2 == (-1,0,1,2)
let x = -1..=2

assert (i for i in 0..=10 step 2) == (0,2,4,6,8,10)

assert 5..=0 step -1 == (5,4,3,2,1,0)

assert((0..<30 step 10) == (0,10,20)) // ranges and tuples can combined
assert((1..=3) ++ 4 == (1,2,3,4))   // tuple and range ops become a tuple
assert 1..=3 == (1,2,3)
assert((1..=3)@[..] == 0b1110)      // convert range to integer with @[..]

a = 'cad'              // c is 0x63, a is 0x61, and d is 0x64
b = 0x64_61_63
assert a == string(b)  // typecast number to string
assert int(a) == b     // typecast string to number
assert a@[..] == b     // typecast string to number

assert "hello" == ('h','e','l','l','o')
assert "h" ++ "ell" == ('h','e','l','l') == "hell"

var bund1 = (color:string, value:s33)
x:bund1        = _      // OK, declare x of type bund1 with default values
bund1.color    = "red"  // OK
bund1.is_green = fun(self) { self.color == "green" }
x.color        = "blue" // OK

let typ = (color:string, value:s33, is_green:fun(self) = _)
y:typ        = _        // OK
typ.is_green = fun(self) { self.color == "green" }
y.color      = "red"    // OK

let bund3 = (color:string, value:s33)
z:bund3        = _                 // OK
z.color        = "blue"            // OK

assert x equals typ  // same type structure
assert z equals typ  // same type structure
assert x equals z    // same type structure

assert y is typ
assert typ is typ
assert z !is bund3 
assert z !is typ
assert z !is bund1

var a = true  // infer a is a boolean

foo = a:bool or false // checks that 'a' is a boolean

// attribute set
var foo:u32:[comptime=true] = xx   // enforce that foo is comptime true always
var bar::[comptime] = xx           // same as previous statement
yyy = xx                           // yyy does not check comptime
yyy::[comptime=true] = xx          // now, checks that 'yyy` is comptime

// attribute check
if bar == 3 {
  tmp = bar::[comptime == true]    // check that this use of bar is comptime
  tmp = bar::[comptime]            // same as previous statement
  tmp = bar ; assert bar.[comptime] // same as previous statements
}
                                   // bar/foo may not be comptime

// attribute read
assert tmp.[bits] < 30 and !tmp.[comptime]

    let x = y::[cond,bar==3] + 1

    read_state = fun(x) {
      let f:u32:[comptime] = x // f is compile time or a error is generated
      return f                 // f should be compile time constant
    }

    var foo = read_state(zz) // foo will be compile time constant

    let x = y + 1
    cassert y.[cond]
    cassert y.[bar]==3

    read_state = fun(x) {
      let f = x
      cassert f does u32
      cassert f.[comptime]
      f
    }

    var foo = read_state(zz) // foo will be compile time constant

if cond::[comptime] {    // cond is checked to be compile time constant
  x::[comptime] = a +1   // x is set to be compile time constant
}else{
  x::[comptime] = b      // x is set to be compile time constant
}


if cond.[comptime] {  // checks if cond is compute at comptime
  let v = cond
  if cond {
    puts "cond is compile time and true"
  }
}

let bad = (a=3,b::[poison]=4)

let b = bad.b

assert b.[poison] and b==4

let counter = proc(en, width) {
  reg value:uint:[bits=width] = 0
  value = value + 1
  value
}

let counter2::[clock_pin=clk1]=counter
let counter3::[reset_pin=rst2]=counter

var ctr2 =#[..] counter2(my_enable)
var ctr3 =#[..] counter3(my_enable)

opt1:uint(300) = 0
opt2:int:[min=0,max=300] = 0  // same
opt3::[min=0,max=300] = 0     // same
opt4:int(0..=300) = 0         // same

assert opt1.[ubits] == 0    // opt1 initialized to 0, so 0 bits
opt1 = 200
assert opt1.[ubits] == 8    // last assignment needs 9 sbits or 8 ubits
tmp  = opt1::[ubits==8] + 1   // expression AND assert opt1.[ubits]==8 check

a:u32 = 100
b:u10 = 0
c:u5  = 0
d:u5  = 0
w:u5:[wrap] = 0     // attribute set for all the 'w' uses

b = a               // OK, o precision lost
c::[wrap] = a       // OK, same as c = a@[0..<5] (Since 100 is 0b1100100, c==4)
w = a               // OK, 'w' has a wrap set at declaration

c::[saturate] = a   // OK, c == 31
c = 31

d::[wrap] = c + 1   // OK d == 0
d::[saturate] = c+1 // OK, d==31
d::[saturate] = c+1 // OK, d==31


let a::[comptime] = 1     // obviously comptime
b::[comptime] = a + 2     // OK too

var Xconst1 = 1      // obvious comptime

var a = (b::[debug]=2, c = 3) // a.b is a debug variable
let c::[debug] = 3

x:(_priv=3, zz=4) = _

let tmp::[debug] = x.priv // OK

assert x._priv == 3    // OK, assert is a debug statement

reg counter:u32   = 10
var not_a_reg:u32 = 20

cassert 1<<(1,4,3) == 0b01_1010

cassert (1,2) in (0,1,3,2,4)
cassert (1,2) in (a=0,b=1,c=3,2,e=4)
cassert (a=2) !in (1,2,3)
cassert (a=2) in (1,a=2,c=3)
cassert (a=1,2) in (3,2,4,a=1)
cassert (a=1,2) !in (1,2,4,a=4)
cassert (a=1) !in (a=(1,2))

cassert (x=nil,c=3) in (x=3,c=3)
cassert (x=nil,c=3) in (x=nil,c=3,d=4)
cassert (c=3)      !in (c=nil,d=4)

cassert ((a=1,c=3) ++ (a=1,b=2,c=nil)) == (a=(1,1), c=3, b=2)
cassert ((1,2) ++ (a=2,nil,5)) == (1,2,a=2,5)
cassert ((x=1) ++ (a=2,nil,5)) == (x=1,a=2,nil,5)

cassert ((x=1,b=2) ++ (x=0sb?,3)) == (x=1,b=2,3)

cassert (1,b=2,...(3,c=3),6) == (1,b=2,3,c=3,6)
cassert (1,b=2,...(nil,c=3),0sb?,6) == (1,b=2,nil,c=3,0sb?,6)

cassert((a=1,b=2) has "a")

cassert (a=1,b=3) does (b=100,a=333,e=40,5)
cassert (a=1,3) does (a=100,300,b=333,e=40,5)
cassert (a=1,3) !does (b=100,300,a=333,e=40,5)

match (a=1,b=3) {
  case (a=1) { cassert true }
  else { cassert false }
}

match let t=(a=1,b=3); t {
  case (a=1  ,c=4) { cassert false }
  case (b=nil,a=1) { cassert t.b==3 and t.a==1 }
  else { cassert false }
}

cassert b does a
x = b in a

x = 0b1_0110   // positive
y = 0s1_0110   // negative
assert x@[0,2] == 0b10
assert y@[100,200]       == 0b11   and x@[100,200]       == 0
assert y@sext[0,100,200] == 0sb110 and x@sext[1,100,200] == 0b001
assert x@|[..] == -1
assert x@&[0,1] == 0
assert x@+[0..=5] == x@+[0..<100] == 3
assert y@[..]@+[..] == 3
assert y@[0..=5]@+[..] == 3
assert y@[0..=6]@+[..] == 4

var z     = 0b0110
z@[0] = 1
assert z == 0b0111

var v = 0b10
assert v@[0,1] == v@[1,2] == v@[..] == v@[0..=1] == v@[..=1] == 0b10

var trans = 0

trans@[0] = v@[1]
trans@[1] = v@[0]
assert trans == 0b01

assert((x or !y) == (x or (!y)) == (x or not y))
assert((3*5+5) == ((3*5) + 5) == 3*5 + 5)

a = x1 or x2==x3 // same as b = x1 or (x2==x3)
c = 3
  & 4 * 4
c2 = 3
  & (4 * 4)
  & (5 + 3)      // OK

d = 3 + 3 - 5    // OK, same result right-left

e = 1
  | 5

f = (1 & 4)
  | (1 + 5)
  | 1

g = 1 + 3
  * 1 + 2
  + 5           // OK, but not nice

g1= 1 + (3 * 1)
  + 2
  + 5           // OK

g2= (1 + 3)
  * (1 + 2)
  + 5           // OK


i = a == 3 <= b == d
assert i == (a==3 and 3<=b and b == d)

assert a <= b <= c  // same as a<=b and b<=c

var v1:u32 = _                 // v1 is zero every cycle AND not valid
assert v1.[valid] == false
var v2:u32 = 0                 // v2 is zero every cycle AND     valid
assert v2.[valid] == true

cassert v1?
cassert not v2?

assert v1 == 0 and v2 == 3     // data still same as usual

v1 = 0sb?                      // OK, poison data
v2 = 0sb?                      // OK, poison data, and update valid
assert v2?                     // valid even though data is not

assert v1 != 0                 // usual verilog x logic
assert v2 != 0                 // usual verilog x logic

let res1 = v1 + 0              // valid with just unknown 0sb? data
let res2 = v2 + 0              // valid with just unknown 0sb? data

assert res1?
assert res2?

reg counter:u32 = 0

always assert counter.reset implies !counter?

let custom = (
  ,data:i16 = _
  ,setter = proc(ref self, v) {
    self.data = v
    self.[valid] = v != 33
  }
)

var x:custom = _

cassert x?
x.data = 33
cassert not x?
x.data = 100
cassert x?

let complex = (
  ,reg v1:string = "foo"
  ,v2:string = _

  ,setter = proc(ref self,v) {
     self.v1 = v
     self.v2 = v
  }
)

var x1:complex = _
var x2:complex:[valid=false] = 0  // toggle valid, and set zero
var x3:complex = 0
x3.[valid] = false                // set invalid

assert x1.v1 == "" and x1.v2 == ""
assert not x2? and not x2.v1? and not v2.v2?
assert x2.v1 == "" and x2.v2 == ""

assert x2?.v1 == "" and x2?.v1 != ""  // any comparison is false

// When x2? is false, any x2?.foo returns 0sb? with the associated x rules

x2.v2 = "hello" // direct access still OK

assert not x2? and x2.v1 == "" and x2.v2 == "hello"

x2 = "world"

assert x2? and x2?.v1 == "world" and x2.v1 == "world"

var a:int = _
cassert a==0 and a.[valid] == false and not a?

var b:int = 0
cassert b==0 and b.[valid] and b?
b = nil
cassert b==nil and b.[valid] == false and not b?

var c:fun(a1) = _
cassert c == nil and c.[valid]==false
c = fun(a1) { cassert true }
cassert c!= nil and c.[valid]

var d:[] = _               // empty tuple
cassert d != nil and d.[valid]
cassert d[0] == nil and !d[0].[valid]

var e:int = nil
cassert e==nil and !e.[valid] and not e?
e = 0
cassert e==0 and e.[valid] and e?

let a = "foo"

var at1 = (
  ,a:string 
)
cassert at1[0] == "foo"
cassert at1 !has "a"    // at1.a undefined

var at2 = (
  ,a:string = _
)
cassert at2.a == ""  and at2.a.[valid]==false
at2.a = "torrellas"
cassert at2.a == "torrellas" and at2[0] == "torrellas"

var at3:at2 = _
cassert at3.a == ""  and at3.a.[valid]==false

var at4:at2 = (a="josep")
cassert at4.a == "josep"  and at4.a.[valid] and at4.[valid]


var x=_
var y=2
var z=_
if rand {
  x = 3
  y = 4
  z = 5
}else{
  z = 6
}
assert x==3  // Simplified due to the _ initialization
assert rand      implies x.[valid]
assert x.[valid] implies rand

assert y.[valid]
assert  rand implies y == 4
assert !rand implies y == 2

assert z.[valid]
assert  rand implies z == 5
assert !rand implies z == 6

a = 3
assert a == 3          // checked at runtime (or compile time)
cassert a == 3         // checked at compile time

optimize b > 3         // may optimize and perform a runtime check

let max_not_zero = fun(a,b) -> (res) 
  requires a>0
  requires b>0
  ensures res==a or res==b {

  res = if a>b {a} else {b}
}

a = 0
if cond {
  a = 3
}
assert cond implies a == 3, "the branch was taken, so it must be 3??"
assert a == 3, "the same error" when   cond
assert a == 0, "the same error" unless cond

let fun1 = fun(a,b) { a | b}
let fun2 = fun(a,b) { ~(~a | ~b) }
lec fun1, fun2

let mul2 = proc(a,b) -> (reg out) {
  reg pipe1 = _

  out = pipe1

  pipe1 = a*b
}

let mul0 = fun(a,b)->(out) { out = a*b }

lec_valid mul0, mult2

// coverage case NUM group states that random should be odd or even
covecase NUM,   random&1 , "odd number"
covecase NUM, !(random&1), "even number"

covercase COND1, reset, "in reset"
covercase COND1, val>3, "bigger than 3"

assert((!reset and val>3) or reset)  // less checks than COND1

cover a==3, "at least a is 3 once in a while"

reg memory:[]u33 = (1,2,3) // may take cycles to load this contents

assert memory[0] == 1 // not checked during reset

always assert memory[1] == 2 // may fail during reset
always assert memory[1] == 2 unless memory.reset  // should not fail

let x:u8 = _

for i in 1..<100 {
  cassert 0 <= x.[crand]  <= 255
}

let get_rand_0_2556 = fun(a:u8) {
  a.[rand]
}

let a = (1,2,3,b=4)
let x = a.[rand]

cassert x==1 or x==2 or x==3 or x==4
cassert x.b==4 when x==4

    let add = fun(a,b) { a+b }

    for a in 0..=20 {
      for b in 0..=20 {
        test "checking add({},{})", a,b {
           cassert a+b == add(a,b)
        }
      }
    }

    let add = fun(a,b) { a+b }

    test "checking add" {
      for a in 0..=20 {
        for b in 0..=20 {
           cassert a+b == add(a,b)
        }
      }
    }

let counter = proc(update)->(value) {
  reg count:u8:[wrap] = 0

  value = count

  count += 1 when update
}

test "counter through several cycles" {
 
  var inp = true
  let x = counter(inp.[defer])  // inp contents at the end of each cycle 

  assert x == 0 // x.value == 0
  assert inp == true

  step

  assert x == 1
  inp = false

  step

  assert x == 1
  assert inp == false
  inp = true

  assert inp == true
  assert x == 1

  step

  assert inp == true
  assert x == 2
}

test "assert should fail" {

 let n = assert.[failed] 
 assert n == false

 assert false // FAILS

 assert assert.[false]

 assert.[failed] = false // disable test failures done when it finishes
}

a = unique if cond == 1 {
    300
  }elif cond == 2 {
    400
  }else{
    500
  }

var x = _
if a { x = 3 } else { x = 4 }

var tmp = x+1

if var x1=x+1; x1 == tmp {
   puts "x1:{} is the same as tmp:{}", x1, tmp
}elif var x2=x+2; x2 == tmp {
   puts "x1:{} != x2:{} == tmp:{}", x1, x2, tmp
}

x = 1
match x {
  == 1            { puts "always true" }
  in 2,3          { puts "never"       }
}
// It is equivalent to:
unique if x == 1  { puts "always true" }
elif x in (2,3)   { puts "never"       }
else              { assert false       }

var hot = match x {
    == 0b001 { a }
    == 0b010 { b }
    == 0b100 { c }
  }

match let one=1 ; one ++ (2) {
  == (1,2) { puts "one:{}", one }      // should always hit
}

for x in 1..=5 {
  let v1 = match x {
    3 { "three" }
    4 { "four" }
    else { "neither"}
  }

  let v2 = match x {
    == 3 { "three" }
    == 4 { "four" }
    else { "neither"}
  }
  cassert v1 == v2
}

var a = 3
a += 1 when false             // never executes 
assert a == 3
assert a == 1000 when a > 10  // assert never executed either

reg my = 3 when some_condition  // no register declared otherwise

return "fail" unless success_condition

{
  var x=1
  var z=_
  {
    z = 10
    var x=_           // compiler error, 'x' is a shawdow variable
  }
  assert z == 10 
}

var yy = {let x=3 ; 33/3} + 1
assert yy == 12

if {let a=1+yy; 13<a} {
  // a is not visible in this scope
  some_code()
}

let doit = fun(f,a) {
  let x = f(a)
  assert x == 7
  return 3
}

let z3 = doit(fun(a) { 
  assert a!=0
  return 7             // exist the current lambda
  100                  // never reached statement
}, 33)
cassert z3 == 3

for i in 0..<100 {
 some_code(i)
}

var bund = (1,2,3,4)
for (index,i) in bund.enumerate() {
  assert bund[j] == i
}

let b = (a=1,b=3,c=5,7,11)
assert b.keys() == ('a', 'b', 'c', '', '')
assert b.enumerate() == ((0,1), (1,3), (2,5), (3,7), (4,11))
let xx= zip(b.keys(), b.enumerate()) 
cassert xx == (('a',0,a=1), ('b',1,b=3), ('c',2,c=5), ('',3,7), ('',4,11))

for (key,index,i) in zip(keys(b),b.enumerate()) {
  assert i==1  implies (index==0 and key == 'a')
  assert i==3  implies (index==1 and key == 'b')
  assert i==5  implies (index==2 and key == 'c')
  assert i==7  implies (index==3 and key == '' )
  assert i==11 implies (index==4 and key == '' )
}

let c = ((1,a=3), b=4, c=(x=1,y=6))
assert c.enumerate() == ((0,(1,a=3)), (1,b=4), (2,c=(x=1,y=6)))

var d = i for i in 0..<5 
var e = i for i in 0..<5 if i
assert (0,1,2,3,4) == d
assert e == (1,2,3,4)

b = (1,2,3,4,5)

for x in ref b {
  x += 1
}
assert b == (2,3,4,5,6)

var total:[] = _
for a in 1..=10 {
  continue when a == 2
  total ++= a
  break when a == 3    // exit for scope
}
assert total == (1,3)

if true {
  code(x)
}

a = 3
var total2:[] = _
while a>0 {
  total2 ++= a
  break when a == 2    // exit if scope
  a = a - 1
  continue
  assert false         // never executed
}
assert total2 == (3,2)

total = i+10 for i in 1..=9 if i<3
assert total == (11, 12)

// a do while contruct does not exist, but a loop is quite clean/close

var a = 0
loop {
  puts "a:{}",a

  a += 1

  break unless a < 10 
} // do{ ... }while(a<10)

var c = 10
assert b.[defer] == 33    // behaves like a postcondition
b = c.[defer]
assert b == 33
c += 20
c += 3

f1 = ring(a, f4.[defer])
f2 = ring(b, f1)
f3 = ring(c, f2)
f4 = ring(d, f3)

reg counter:u32 = _

let counter_0  = counter#[0]  // current cycle 
let counter_1  = counter#[-1] // last cycle
let counter_2  = counter#[-2] // last last cycle cycle 

var deferred = counter.[defer]

if counter < 100 {
  counter += 1
}else{
  counter = 0
}

if counter == 10 {
  assert deferred   == 10
  assert counter_0  ==  9
  assert counter_1  ==  8
  assert counter_2  ==  7
}

var a = 1
assert a == 1 and a.[defer] == 200

a::[defer] = 100
assert a == 1 and a.[defer] == 200

a::[defer] = 200
assert a == 1 and a.[defer] == 200

var a = 1
var x = 100
x::[defer] = a
a = 200

cassert x == 100
assert x.[defer] == 1

test "my test {}", 1 {
  assert true
}

    let add = fun(a,b) { a+b }

    for i in 0..<10 { // 10 tests
      let a = (-30..<100).rand
      let b = (-30..<100).rand

      test "test {}+{}",a,b {
        assert add(a,b) == (a+b)
      }
    }

    let add = fun(a,b) { a+b }

    test "test 10 additions" {
      for i in 0..<10 { // 10 tests
        let a = (-30..<100).rand
        let b = (-30..<100).rand

        assert add(a,b) == (a+b)
      }
    }

    test "wait 1 cycle" {
      let a = 1 + input
      puts "printed every cycle input={}", a
      step 1
      puts "also every cycle a={}",a  // printed on cycle later
    }

    test "wait 1 cycle" {
      {
        let a = 1 + input
        puts "printed every cycle input={}", a
      } #> {
        puts "also every cycle a={}",a  // printed on cycle later
      }
    }

    total = 3

    waitfor a_cond  // wait until a_cond is true

    assert total == 3 and a_cond

    total = 3

    while !a_cond {
      step
    }

    assert total == 3 and a_cond

    let add=fun(a,b)->(res) {
      res = a+b
    }

    let add=proc(a,b)->(res) {  // nicer to use fun, but proc works
      res = a+b
    }

    let add=proc(reg a, reg b)->(res) {
      res = a+b
    }

    let add=proc(a, b)->(reg res) {
      res = a+b
    }

let a_3   = {   3 }      // just scope, not a lambda. Scope is evaluate now
let a_fun = fun() { 4 }  // when a_fun is called 4 is returned

let fun3 = fun(){ 5 }    // public lambda that can be imported by other files

let x = a_fun()          // OK, explicit call needed when no arguments

assert a_3() equals 3
assert a_fun equals _:fun()
assert a_fun() equals 4
assert a_fun() == 4      // calls to eval the function



var add:fun(...x) = _
add = fun (...x) { x.0+x.1+x.2 }      // no IO specified
add = fun (a,b,c){ a+b+c }            // constrain inputs to a,b,c
add = fun (a,b,c){ a+b+c }            // same
add = fun (a:u32,b:s3,c){ a+b+c }     // constrain some input types
add = fun (a,b,c) -> (x:u32){ a+b+c } // constrain result to u32
add = fun (a,b,c) -> (res){ a+b+c }   // constrain result to be named res
add = fun (a,b:a,c:a){ a+b+c }        // constrain inputs to have same type
add = fun <T>(a:T,b:T,c:T){ a+b+c }   // same

x = 2
var add2:fun2(a) = _
add2 = fun[x    ](a){   x + a }    // explicit capture x
add2 = fun[foo=x](a){ foo + a }    // capture x but rename to something else

var y = (
  ,val:u32 = 1
  ,inc1 = fun (ref self) { self.val = u32(self.val + 1) }
)

let my_log::[debug] = fun (...inp) {
  print "loging:"
  for i in inp {
    print " {}", i
  }
  puts
}

let f = fun<X>(a:X,b:X){ a+b }   // enforces a and b with same type
assert f(33:u22,100:u22)

my_log a, false, x+1

let div  = fun (self,b) { self / b }  // named input tuple
let div2 = fun (...x){ x.0 / x.1 }    // unnamed input tuple

let noarg = fun () { 33 }         // explicit no args

assert 33 == noarg()
                      

b=div(self=8, b=4)       // OK, 2
d=(self=8).div(b=2)      // OK, 4
d=(8).div(b=2)           // OK, 4 . self does not need to be named
d=8.div(2)               // OK, single character inputs no need to be named

h=div2(8, 4, 3)          // OK, 2 (3rd arg is not used)

j=(8,4)  |> div2         // OK, 2, same as div2(8,4)
j=(8,4)  |> div2()       // OK, 2, same as div2(8,4)
k=(4)    |> div2(8)      // OK, 2, same as div2(8,4)
l=(4,33) |> div2(8)      // OK, 2, same as div2(8,4,33)


var tup = (
  ,let f1 = fun(self) { 1 }
)

let f2 = fun (self){ 3 }


let xx = fun[tup] { tup.f1() } // OK, function restricted scope for f1
assert xx()

assert (4:tup).f1() == 1
assert 4.f2()       == 3  // UFCS call
assert tup.f1()     == 1

var tup2 = (
  ,val:u8 = _
  ,upd = proc(ref self) { self.val::[saturate] += 1 }
  ,calc = fun(self) { self.val}
)

no_arg_fun()     // must use explicit parenthesis/called
arg_fun 1,2      // parenthesis are optional
arg_fun(1,2)     // OK too
(1,2) |> arg_fun // OK too, it is after |>

var intercepted:(
 ,field:u32
 ,getter=fun(self) { self.field + 1 }
 ,setter=fun(ref self,v ) { self.field = v }
) = 0

cassert intercepted == 1  // will call get method without explicit call
cassert intercepted.field == 0

let inc1 = fun(ref a) { a += 1 }

let x = 3

var y = 3
inc1(ref y)
assert y == 4

let banner = fun() { puts "hello"  }
let execute_method = fun(fn) {
  fn() // prints hello when banner passed as argument
}

execute_method(banner)     // OK

let ret1 = fun()->(a:int) { // named
  a = 1
}

let ret2 = fun()->a:int {   // unnamed
  a = 2
}

let ret3 = fun()->(a,b) {   // named
  a = 3
  b = 4
}

let a1 = ret1()
assert a1.a == 1 // NOT a1 == 1

let a2 = ret2()
assert a2 == 1   // NOT a2.a == 1

let a3 = ret3()
assert a3.a == 3 and a2.b == 4

let (x1,x2) = ret3()
assert x1   == 3 and x2   == 4

let p1 = proc(a)->(res) {
  self.[my_zero_found] or= (a == 0)

  res = a + 1
}

let p2 = p1      // copy
let p3 = ref p1  // reference

test "testing p1" {
  assert p1.[my_zero_found] == false
  assert p2.[my_zero_found] == false

  cassert p1(3) == 4
  assert p1.[my_zero_found] == false

  cassert p1(0) == 1
  assert p1.my_zero_found == true

  cassert p1(50) == 51
  assert p1.[my_zero_found] == true
  assert p2.[my_zero_found] == false
  assert p3.[my_zero_found] == true
}

let Nested_call = (
  ,var x = 1
  ,let outter= proc(ref self) {  self.x = 100 ; self.inner(); self.x = 5 }
  ,let inner = fun(self) { assert self.x == 100 }
)

var a_1 = (
  ,x:u10
  ,let f1 = fun(ref self,x)->(self) { // BOTH ref self and return self is OK
    self.x = x 
    self
  }
)

a_1.f1(3)
var a_2 = a_1.f1(4)  // a_2 is updated, not a_1
assert a_1.x == 3 and a_2.x == 4

// Same behavior as in a function with UFCS
fun2 = fun (ref self, x) { self.x = x }

a_1.fun2(10)    
var a_3 = a_1.fun2(20)
assert a_1 == 10 and a_3 == 20

var counter = (
  ,var val:i32 = 0
  ,let inc = fun (ref self, v){ self.var += v }
)

assert counter.val == 0
counter.inc(3)
assert counter.val == 3

let inc = fun (ref self, v) { self.var *= v } // NOT INC but multiply
assert 44.inc(2) == 8

counter.val = 5
let mul = inc
counter.mul(2)             // call the new mul method with UFCS
assert counter.val == 10

mul(counter, 2)            // also legal
assert counter.val == 20

let t1 = (a:u32)

var x:t1 = (a=3)

t1.double = proc(ref self) { self.a *= 2 }  // extension function
// previous is exactly the same as:
// t1 = t1 ++ (double = proc(ref self) { self.a *= 2 })

var y:t1 = (a=3)
y.double             // OK
assert y.a == 6

    foo = fun (self) { puts "fun.foo" }
    a = (
      ,foo = fun () {
         bar = fun() { puts "bar" }
         puts "mem.foo"
         return (bar=bar)
      }
    )
    b = 3
    c = "string"

    b.foo         // prints "fun.foo"
    b.foo()       // prints "fun.foo"
    x = a.foo     // prints "mem.foo"
    y = a.foo()   // prints "mem.foo"
    x()           // prints "bar"

    a.foo.bar()   // prints "mem.foo" and then "bar"
    a.foo().bar() // prints "mem.foo" and then "bar"
    a.foo().bar   // prints "mem.foo" and then "bar"

    c.foo         // prints "fun.foo"

    foo = fun (self:int) { puts "fun.foo" }
    a = (
      ,foo = fun () {
         bar = fun() { puts "bar" }
         puts "mem.foo"
         return (bar=bar)
      }
    )
    b = 3
    c = "string"

    b.foo         // prints "fun.foo"
    b.foo()       // prints "fun.foo"
    x = a.foo     // prints "mem.foo"
    y = a.foo()   // prints "mem.foo"
    x()           // prints "bar"

    a.foo.bar()   // prints "mem.foo" and then "bar"
    a.foo().bar() // prints "mem.foo" and then "bar"
    a.foo().bar   // prints "mem.foo" and then "bar"


let fib1 = fun(n) where n==0 {0}
        ++ fun(n) where n==1 {1}
        ++ fun(n)            { fib1(n-1) + fib1(n-2) }

assert fib1(10) == 55

let fib2 = fun(n) {
  return match n {
    == 0 {0}
    == 1 {1}
    else {fib2(n-1) + fib2(n-2)}
  }
}

assert fib2(10) == 55

var res:s4 = _
if cond {
  res = a
}else{
  res = b
}

// RTL equivalent (bus of 4 bits in a,b,res2)
var res2:s4 = __mux(cond,b,a)

lec res, res2

var res = if cond { a }else{ b }

// RTL equivalent
var res2 = __mux(cond,b,a)

lec res, res2

var res = a
res = b unless cond

// RTL equivalent
var res2 = __mux(cond,b,a)

lec res, res2

var res = a
if cond1 {
  res = b
}elif cond2 {
  res = c
}else{
  assert true // no res
}

// RTL equivalent
var tmp = __mux(cond2, a, c)
var res2= __mux(cond1, tmp, b)

lec res, res2

var res = a
unique if cond1 {
  res = b
}elif cond2 {
  res = c
} // no res in else

// RTL equivalent
var sel = (!cond1 and !cond2, cond1, cond2)@[..]  // one hot encode
var res2= __hotmux(sel, a, b, c)
optimize !(cond1 and cond2)                       // one hot check

lec res, res2

var res = a
match x {
  == c1 { res = b }
  == c2 { res = c }
  == c3 { res = d }
}

// RTL equivalent
let cond1 = x == c1
let cond2 = x == c2
let cond3 = x == c3
var sel = (cond1, cond2, !cond1 and !cond2)@[..]  // one hot encode (no cond3)
var res2= __hotmux(sel, b, c, d)
optimize ( cond1 and !cond2 and !cond3)
      or (!cond1 and  cond2 and !cond3)
      or (!cond1 and !cond2 and  cond3)    // one hot check (no else allowed)

lec res, res2

    var lhs = v1 or_else v2

    // RTL equivalent
    let lhs2  = __or(v1, v2)
    let lhs2_v = __or(__and(v1?, v1), __and(v2?, v2))

    lec lhs , lhs2
    lec lhs?, lhs2_v

    var lhs = v1 + v2

    // RTL equivalent
    let lhs2   = __sum(A=(v1, v2))
    let lhs2_v = __and(v1?, v2?)

    lec lhs , lhs2
    lec lhs?, lhs2_v

    lhs = v0
    if cond1 {
      lhs = v1
    }elif cond2 {
      lhs = v2
    } // no else

    // RTL equivalent
    let tmp = __mux(cond2, v0, v2)
    let lhs2= __mux(cond1, tmp, v1)

    let tmp_v = __mux(cond2, v0?, v2?)
    let lhs2_v= __mux(cond1, tmp_v, v1?)

    lec lhs , lhs2
    lec lhs?, lhs2_v

    let f = fun(a,b) { if a == 0 { 3 }else{ b } }

    var lhs = c
    if cond {
       lhs = f(a,b)
    }

    // RTL equivalent
    let a_cond = __not(__ror(a))             // a == 0
    let tmp    = __mux(a_cond, b, 3)         // if a_cond { 3 }else{ b }
    var lhs2   = c
    lhs2       = __mux(cond, x, tmp)

    let tmp_v  = __mux(a_cond, a?, __and(a?,b?)) // a? or (a==0 and b?)

    let lhs2_v = __mux(cond, c?, tmp_v)

    lec lhs , lhs2
    lec lhs?, lhs2_v

    let sub = proc(a,b)->(x) {
      let tmp = sum(a,b)       // instance tmp,sum

      x = sum(tmp,3)           // instance x,sum
    }

    let top = proc(a,b,c)->(x) {

     x = sub(a,b).x
     if c {
       let tmp=3
       x += sub(b,tmp).x
     }
    }

    let sub = proc(a,b)->(x) {
      let tmp = sum(a,b)       // instance tmp

      x = sum(tmp,3)           // instance x
    }

    let top = proc(a,b,c)->(x) {

     x = sub(a,b).x           // instance x

     let x_0 = _
     let sub_arg_0 = _
     let sub_arg_1 = _
     if c {
       let tmp=3
       sub_arg_0 = b
       sub_arg_1 = tmp
       x += x_0.[defer]       // use defer (instance after conditional code)
     }
     x_0 = sub(sub_arg_0,sub_arg_1).x   // instance x_0 (SSA)
    }

    let case_1_counter = proc(runtime)->(res) {

      let r = (
        ,reg total:u16 = _          // r is reg, everything is reg
        ,increase = fun(a) {
          puts "hello"

          let res = self.total
          self.total::[wrap] = res+a

          res
        }
      )

      if runtime == 2 {
        res = r.increase(3)
      }elif runtime == 4 {
        res = r.increase(9)
      }
    }

    let case_1_counter = proc(runtime)->(res) {

      let r = (
        ,reg total:u16 = _
        ,increase = fun(a) {
          puts "hello"

          let res = self.total
          self.total::[wrap] = res+a

          res
        }
      )

      if runtime == 2 {
        puts "hello"

        let res = r.total
        r.total::[wrap] = res+3
        res = res
      }elif runtime == 4 {
        puts "hello"

        let res = r.total
        r.total::[wrap]= res+9
        res = res
      }
    }

reg r:u16 = 3 // reset sets r to 3
r = 2             // non-reset assignment

reg array:[]u16 = (1,2,3,4)  // reset values

reg r2:u128 = conf.get("my_data.for.r2")

reg array:[] = conf.get("some.conf.hex.dump")

reg array:[1024]tag:[clock_pin=my_clock] = proc(ref self) {
  reg reset_iter:u10:[reset_pin=false] = 0sb? // no reset flop

  self[reset_iter].state = I

  reset_iter::[wrap] = reset_iter + 1
}

reg my_flop:[8]u32 = proc(ref self) {
  reg reset_counter:u3:[async=true] = _ // async is only posedge reset

  self[reset_counter] = reset_counter
  reset_counter::[wrap] += 1
}

    let Mix_tup = (
      ,reg flag:bool = false
      ,state: u2
    )

    var x:Mux_tup = (false,1)  // 0 used at reset, 1 used every cycle

    assert x.flag implies x.state == 2

    x.state = 0
    if x.flag {
      x.state = 2
    }
    x.flag = true

    let Mix_tup = (
      ,reg flag:bool = false
      ,state:u2
    )

    var x:Mux_tup = proc(ref self) {
      self.flag  = proc(ref self) { self = false }  // reset code
      self.state = 2                                // every cycle code
    }

    assert x.flag implies x.state == 2

    x.state = 0
    if x.flag {
      x.state = 2
    }

reg my_asyn_other_reg:u8:[
  ,async = true
  ,clock = ref clk2    // ref to connect, not read clk2 value
  ,reset = ref reset33 // ref to connect, not read current reset33 value
] = 33 // initialized to 33 at reset


if my_async_other_reg == 33 {
  my_async_other_reg = 4
}

assert my_async_other_reg in (4,33)



    let inner = fun(z,y)->(a,h) {
      a =   y & z
      h = !(y & z)
    }

    let top2 = fun(a,b)->(c,d) {
      let x= inner(y=a,z=b)
      c = x.a
      d = x.h
    }

    let Inner_t = (
      ,setter = proc(ref self, z,y) {
        self.a =   y & z
        self.h = !(y & z)
      }
    )

    let Top2_t = (
      ,setter = proc(ref self,a,b) {
        let foo:Inner_t = (y=a,z=b)
        
        self.c = foo.a
        self.d = foo.h
      }
    )

    let top:Top2_t = (a,b)

    let Inner_t = (
      ,setter = proc(ref self, z,y) {
        self.a =   y & z
        self.h = !(y & z)
      }
    )

    let Top2_t = (
      ,foo:Inner_t = _
      ,setter = proc(ref self,a,b) {
        (self.c, self.d) = self.foo(y=a,z=b)
      }
    )

    let top:Top2_t = (a,b)

reg a:u4 = 3
a::[saturate] = a+1

reg b = 4
if cond {
  reg c = _           // weird as reg, but legal syntax
  c = b + 1
  b = 5
}

// RTL equivalent
a_qpin = __flop(reset=ref reset, clk=ref clk, initial=3, din=a.[defer])
tmp    = __sum(A=(a_qpin, 1))
a      = __mux(tmp[4], tmp@[0..=3], 0xF)    // saturate, not wrap

b_qpin = __flop(reset=ref reset, clk=ref clk, initial=4, din=b.[defer])
b      = __mux(cond, b_qpin, 5)

c_cond_qpin = __flop(reset=ref reset, clk=ref clk, initial=0, din=c_cond.[defer])
c_cond      = __sum(A=(b, 1))

    var counter_next:u8:[wrap] = _

    let counter_q = __flop(din=counter_next.[defer] // defer to get last update
                       ,reset_pin=my_rst, clock_pin=my_clk
                       ,enable=my_enable            // enable control
                       ,posclk=true
                       ,initial=3                   // reset value
                       ,async=false)

    counter_next = counter_q + 1

    reg counter:u8:[reset_pin=my_rst, clock_pin=my_clk, posclk=true]= 3
    assert counter == counter#[0]  // counter still has the q value

    if my_enable {
      counter::[wrap] = counter + 1
    }

var my_latch_q = __latch(din=my_din, enable=my_enable, posclk=true)

// variables/register before

{
  // stage 0 scope
} #> {               // no identifier, 1 stage by default
  // stage 1 scope
} #>foo[2] {            // no identifier, 2 stages
  // stage 2-3 scope
} #>bar[1] {     // 'free_stage' identifier, 1 stages
  // stage 4 scope
} #> {
  // stage 5 scope
}

// variables/register after pipestage

assert i==0 or (i#[-1] + 1 == i)

let i_let = i

var i_var0 = i
var i_var1 = i

reg i_reg0 = i        // initialization only
reg i_reg1:i_reg0 = _

i_reg1 = i                // every cycle

{
  assert i == i#[0]       // i#[0] is unflop input (or first defined) value
  assert i == i_let
  assert i == i_var0
  assert i == i_var1

  assert 0 == i_reg0
  assert i == i_reg1

  let _local_var = 3

  let pub_var = 100 + i

} #> {
  assert pub_var == 100 + i // pipelined pub_var

  // both inputs and variables flop, so asserts hold
  assert i == i_let
  assert i == i_var0
  assert i == i_var1

  assert 0 == i_reg0        // i_reg0 never changes, so 0 is fine
  assert i#[-1] == i_reg1   // last i-reg, not current

  assert i == 0 or (i == i#[0]+1)  // i#[0] is the unflop original
}


let bad_code = proc(my_clk, inp)->(o1,o2) {

  {
    o1 = 1
    o2 = inp + 1  // o2? iff bad_code called this cycle and inp? is valid
  } #>my_pipe[lat=1,clock=my_clk] {
    o2 = inp + 2  // may be OK if inp is not valid every cycle
  }

}

    let mul3=proc(a,b)->res {
      let tmp = a*b
      #>full_case[lat=3,num=3] { // Same as full_case[lat=3]
        res = tmp
      }
    }

    let mul_slow=proc(a,b)->res {

      let result  = 0
      let rest    = a

      while rest >= b #>_[lat=1,num=4] {  // lat=1 is latency per iteration
        rest = rest - b
        result += 1
      }

      res = result
    }

    let mul1=proc(a,b)->(reg res) {
      res = a*b
    }

    let mul1=proc(a,b)->(res) {
      #>full_case_again[lat=1] { 
        res = a*b
      }
    }

    let mul0=proc(a,b)->(res) {
      res = a*b
    }

if cond {
  var p1 = inp1
  var out = _

  {
    var _l1 = inp1 + 1

    var p2 = inp1 + 2
  } #> {
    out = p1 + p2
  }

  res = out
}

// Non pipestage equivalent
if cond {
  var p1 = inp1
  var out = _

  {
    reg p1r = _
    reg p2r = _

    var l1::[private] = inp1 + 1  // private
    var p2 = inp1 + 2             // public

    out = p1r + p2r               // registered values

    p1r = p1
    p2r = p2
  }

  res = out
}

reg my_reg::[retime=true,clock=my_clk] = 0

    let block = proc(in1,in2)->(out) {
      {
        let tmp = in1 * in2
      } #>some_id[lat=3] {
        out = tmp + in1#[0]
      }
    }

    add1 = proc(a,b) {     // 1 cycle add
      reg r  = _
      let rr = r           // get flop value
      r = a+b
      return rr
    }
    let mul3 = proc(a,b) { // 3 cycle multiply
      reg reg1 = _
      reg reg2 = _
      reg reg3 = _
      reg3 = reg2
      reg2 = reg1
      reg1 = a * b
      return reg3
    }

    let block = proc(in1,in2)->(out) {
      let x =#[..] mul3(in1, in2)
      out   =#[..] add1(x,in3)
    }



let x =#[..] mul3(in1, in2) // OK
out  =#[..] add1(x,in3)     // OK (in3 has 0 cycles, x has 3 cycles)
out  =#[1..<4] add1(x,in3)  // OK



    {
      let tmp = in1 * in2
    } #>fully_pipe[lat=3] {
      out = tmp + in1
    }

    x =#[..] mul3(in1, in2)
    y = in1#[-3]
    out =#[..] add1(a=x,b=y)    // connect in1 from -3 cycles

let quick_log2 = fun(a) {

  cassert a>=1

  var i = 1
  var v = 0
  while i < a.[bits] {
    v |= i
    i *= 2
  }

  return v
}

let div=proc(a,b,id)->(res,id) {
  loop #>free_div_units[4] {
    return (a >> quick_log2(b), id) when b@+[..] == 1
    #>my_fsm[lat=5,num=1] {
      res = (a/b, id)
    }
  }
}

let mul=proc(a,b,id)->(res, id) {
  #>pending_counter[lat=3,num=2] {
    res = a*b
    id  = id
  }
}

let add=proc(a,b,id)->(res,id) {
  #>add_counter[lat=1] {         // Fully pipeline, num not specified
    res = a+b
    id  = id
  }
}

let alu = proc(a,b,op, id)->(res,id) {

  self.[total_free_units] = 1 
     + mul.[pending_counter] 
     + div.[free_div_units]
     + add.[add_counter]

  self.[div_units] = div.[free_div_units]

  match op {
    == OP.div {
      assert div.[free_div_units]>0
      (res,id) = div(a,b,id)
    }
    == OP.mul { (res,id) = mul(a,b,id) }
    == OP.add { (res,id) = add(a,b,id) }
  }
}

test "alu too many div" {

 cassert alu.[total_free_units] == (1+3+4)

 let r1 = alu(13,3, OP.div, 1)
 assert alu.div_units==3
 let r2 = alu(13,3, OP.div, 2)
 assert alu.div_units==2
 let r3 = alu(13,3, OP.div, 3)
 assert alu.div_units==1
 let r4 = alu(13,3, OP.div, 4)
 assert alu.div_units==0

 assert !r1? and !r2? and !r3? and !r4? // still invalid

 let r5 = alu(13,4, OP.mul,5)
 cassert mul.[pending_counter] == 2
}

    var b = "hello"

    var a:u32 = 0

    a += 1

    a = b                       // incorrect


    var dest:u32 = 0

    dest = foo:u16 + v:u8

    var b = "hello"

    var a:u32 = 0

    a += 1
    cassert a does u32
    a = b                       // incorrect
    cassert b does u32  // fails

    var dest:u32 = 0
    cassert (dest does u32) and (foo does u16) and (v does u8)
    dest = foo:u16 + v:u8

let t1 = (a:int=1  , b:string)
let t2 = (a:int=100, b:string)
var v1 = (a=33     , b="hello")

let f1 = fun() {
  return (a=33     , b="hello")
}

assert t1    equals t2
assert t1    equals v1
assert f1()  equals t1
assert _:f1 !equals t1
assert _:t1  equals t2

let At:int(33..) = _      // number bigger than 32
let Bt=(
  ,c:string = _
  ,d=100
  ,setter = fun(ref self, ...args) { self.c = args }
)

var a:At=40
var a2 = At(40)
cassert a == a2

var b:Bt="hello"
var b2 = Bt("hello")
cassert b == b2

puts "a:{} or {}", a, at // a:40 or 33
puts "b:{}", b           // b:(c="hello",d=100)

assert (a:int:(max=33,min=0) does (a:int(20,5)))
assert (a:int(0..=33)       !does (a:int(50,5)))

assert  (a:string,b:int) does (a:"hello", b:33)
assert ((b:int,a:string) !does (a:"hello", b:33)) // order maters in tuples

assert  _:fun(x,xxx2)->(y,z) does _:fun(x     )->(y,z)
assert (_:fun(x     )->(y,z) !does _:fun(x,xxx2)->(y,z))

let t1 = (a:string, b:int)
let t2 = (b:int, a:string)

var a:t1  = ("hello", 3)     // OK
var b:t1  = (a="hello", 3)   // OK
var c:t1  = (a="hello", b=3) // OK
var c1:t1 = (b=3, a="hello") // OK

var d:t2 = c                 // OK, both fully named
assert d.0 == c.1 and c.0 == d.1
assert d.a == c.a and d.b == c.b

let a = fun() { 1 }
let b = fun() { 2 }
assert a equals _:fun()    // 1 !equals :fun()

assert a() != b()              // 1 != 2
assert a() equals b()          // 1 equals 2

assert _:a equals _:fun()

cassert (a:u32=0, b:bool) does (a:u32, c:string="hello", b=false)
cassert (a:u32=0, c:string="hello", b=false) case (a = 0, b:bool) // b is nil

cassert (a:u32=0, c:string="hello", b=false) !case (a:u32 = 1 , b:bool=nil )
cassert (a:u32=0, c:string="hello", b=false) !case (a:bool=nil, b:bool=nil )
cassert (a:u32=0, c:string="hello", b=false) !case (a = 0     , b     =true)

let a = 3
let b = 200
cassert a is b

let c:u32 = 10
cassert a !is c
cassert a::[typename] == "int" and c::[typename] == "u32"

let d:u32 = nil
cassert c is d

let e = (a:u32=1)
let f:(a:u32) = 33
cassert e is f

let X1 = (b:u32)
let X2 = (b:u32)

let t1:X1 = (b=3)
let t2:X2 = (b=3)
assert (b=3) !is X2  // same as (b=3) !is X2
assert t1 equals t2
assert t1 !is t2

let t4:X1 = (b=5)

assert t4  equals t1
assert t4  is     t1
assert t4 !is     t2

let f2 = fun(x) where x is X1 {
  x.b + 1
}

let Rgb = (
  ,c:u24
  ,setter = proc(ref self, c) { self.c = c }
)

let Color = enum(
  ,Yellow:Rgb = 0xffff00
  ,Red:Rgb    = 0xff0000
  ,Green      = Rgb(0x00ff00) // alternative
  ,Blue       = Rgb(0x0000ff)
)

var y:Color = Color.Red
if y == Color.Red {
  puts "c1:{} c2:{}\n", y, y.c  // prints: c1:Color.Red c2:0xff0000
}

let ADT=enum(
  ,Person:(eats:string) = _
  ,Robot:(charges_with:string) = _
)

let nourish = fun(x:ADT) {
  match x {
    == ADT.Person { puts "eating:{}"  , x.eats         }
    == ADT.Robot  { puts "charging:{}", x.charges_with }
  }
}

test "my main" {
  (_:Person="pizza", _:Robot="electricity").each(nourish)
}

var val:u8 = 0   // designer constraints a to be between 0 and 255
assert val.[sbits] == 0

val = 3          // val has 3 bits (0sb011 all the numbers are signed)


val = 1          // max=1,min=1 sbits=2, ubits=1
assert val.[ubits] == 1 and val.[min]==1 and val.[max]==1 and val.[sbits]==2

val::[wrap] = 0x1F0 // Drop bits from 0x1F0 to fit in constrained type
assert val == 240 == 0xF0

val = u8(0x1F0)    // same
assert val == 0xF0

var a = 3                  // a: current(max=3,min=3) constrain()
var c:int(0..=10) = _      // c: current(max=0,min=0) constrain(max=10,min=0)
if b {
  c = a+1                  // c: current(max=4,min=4) constrain(max=10,min=0)
}else{
  c = a                    // c: current(max=3,min=3) constrain(max=10,min=0)
}
                           // c: current(max=4,min=3) constrain(max=10,min=0)

var e::[sbits = 4] = _     // e: current(max=0,min=0) constrain(max=7,min=-8)
e = 2                      // e: current(max=2,min=2) constrain(max=7,min=-8)
var d = c                  // d: current(max=4,min=3) constrain()
if d==4 {
  d = e + 1                // d: current(max=3,min=3) constrain()
}
var g:u3 = d               // g: current(max=4,min=3) constrain(max=7,min=0)
var h = c@[0,1]            // h: current(max=3,min=0) constrain()

if cmd? {
  (x,y) = cmd   // x.max=cmd.a.max; x.min = 0 (uint) ; ....
}elif x > y {
                // narrowing: x.min = y.min + 1 = 1
                // narrowing: y.max = x.min - 1
  x = x - y     // x.max = x.max - x.min = x.max - 1
                // x.min = x.min - y.max = 1
}else{          // x <= y
                // narrowing: x.max = y.min
                // narrowing: y.min = x.min
  y = y - x     // y.max = y.max - x.min = y.max
                // y.min = y.min - x.max = 0
}
                // merging: x.max = x.max ; x.min = 0
                // merging: y.max = y.max ; y.min = 0
                // converged because x and y is same or smaller at beginning

reg x = 0
reg y = 0
if cmd? {
  (x,y) = cmd
}elif x > y {
  x = x - y
}else{
  y = y - x
}
x:cmd.a:[wrap] = x  // use cmd.a type for x, and drop bits as needed
y = cmd.b(y)        // typecast y to cmd.b type (this can add a mux)

let e_type=enum(str:String = "hello",num=22)
let v_type=variant(str:String, num:int) // No default value in variant

var vv:v_type = (num=0x65)
cassert vv.num == 0x64
let xx = vv.str                         // compile or simulation error

let Vtype=variant(str:String,num:int,b:bool)

let x1a:Vtype = "hello"                 // implicit variant type
let x1b:Vtype = (str="hello")           // explicit variant type

var x2:Vtype:[comptime] = "hello"       // comptime

cassert x1a.str == "hello" and x1a == "hello"
cassert x1b.str == "hello" and x1b == "hello"

let err1 = x1a.num                      // compile or simulation error
let err2 = x1b.b                        // compile or simulation error

var ee = e_type

match ee {
 == e_type.str { }
 == e_type.num { }
}

let at=(c:string,d:u32)
let bt=(c:string,d:u100)

let ct=(
  ,d:u32    = _
  ,c:string = _
)
// different order
let dt=(
  ,d:u32    = _
  ,c:string = _
  ,setter = proc (ref self, x:at) { self.d = x.d ; self.c = x.c }
)

var b:bt=(c="hello", d=10000)
var a:at=_

a = b          // OK c is string, and 10000 fits in u32

var c:ct= a    // OK even different order because all names match

var d:dt = a   // OK, call intitial to type cast

a = (b=1,c:u32=2)
var b = a
b.c=100

assert a equals b
assert a.size == 2
assert a['b'] == 1
assert a['c'] equals u32

assert   a has 'c'
assert !(a has 'foo')

assert a.[id] == 'a'
assert a.0.[id] == ':0:b' and a.b.[id] == ':0:b'
assert a.1.[id] == ':1:c' and a.c.[id] == ':1:c'

let fu = fun(a,b=2) -> (c) where a>10 { c = a + b }
assert fu.[inp] equals ('a','b')
assert fu.[out] equals ('c')
assert fu.[where](a=200) and !fu.[where](a=1)

let x:u32 = fn(a1,a2)

let model_poly_call = fun(fn, ...args)->(out) {
  for f in fn {
     continue unless f.[inp] does args
     continue unless f.[out] does out
     return f(args) when i.[where](args)
  }
}
let x:u32 = model_poly_call(fn, a1, a2)

let randomize::[debug] = fun(ref self) {
  let rnd = import("prp/rnd")
  for i in ref self {
    if i equals _:int {
      i = rnd.between(i.[max],i.[min])
    }elif i equals _:bool {
      i = rnd.boolean()
    }
  }
  self
}

let x = (a=1,b=true,c="hello")
let y = x.randomize

assert x.a==1 and x.b==true and x.c=="hello"
cover  y.a!=1
cover  y.b!=true
assert y.c=="hello"  // string is not supposed to mutate in randomize()

// file: src/my_fun.prp
let fun1    = fun(a,b) { a+b }
let fun2    = fun(a) {
  let inside = fun() { 3 }
  a
}
let another = fun(a) { a }

let mytup = (
  ,call3 = fun() { puts "call called" }
)

// file: src/user.prp
a = import("my_fun/*fun*")
a.fun1(a=1,b=2)         // OK

let fun1 = import("my_fun/fun1")
lec fun1, a.fun1

x = import("my_fun/mytup")

x.call3()                // prints call called

let a = import("prj1/file1")
let b = import("file1")       // import xxx_fun from file1 in the local project
let c = import("file2")       // import the functions from local file2
let d = import("prj2/file3")  // import the functions from project prj2 and file3

let b = import("prp/Number")
var a = import("fancy/Number_mixin")

let Number = b ++ a // patch the default Number class

var x:Number = 3

let do_increase = proc() {
  reg counter = 0

  counter:u32:[wrap] = counter + 1
}

let do_debug = proc() {
  let cntr = regref("do_increase/counter")

  puts "The counter value is {}", cntr
}

// file remote.prp

let xxx = proc(some,code) {
  reg uart_addr:u32 = _
  assert 0x400 > uart_addr >= 0x300
}

// file local.prp
let setup_xx = proc() {
  var xx = regref("uart_addr") // match xxx.uart_addr if xxx is in hierarchy
  var index = 0
  for val in ref xx {          // ref does not allow enumerate
    val = 0x300+index*0x10     // sets uart_addr to 0x300, 0x310, 0x320...
    index += 1
  }
}

let bpred = ( // complex predictor
  ,let taken = fun(){ self.some_table[som_var] >=0 }
)

test "mocking taken branches" {
  poke "bpred_file/taken", true

  var l = core.fetch.predict(0xFFF)
}

let Typ1 = (
  ,a:string = "none"
  ,b:u32    = 0
)

let w      = Typ1(a="foo", b=33)  // OK
let x:Typ1 = (a="foo", b=33)      // OK, same as before

let v:Typ1 = Typ1(a="foo", b=33)  // OK, but redundant Typ1
let y:Typ1 = ("foo", 33)          // OK, because no conflict by type

var z:Typ1 = _                    // OK, default field values
cassert z.a == "none" and z.b == 0
z = ("foo",33)

cassert v==w==x==y==z

let Typ2 = (
  ,a:string = "none"
  ,b:u32    = 0
  ,setter = proc(ref self, a, b) { self.a = a ; self.b = b }
)

var x:Typ2 = (a="x", b=0)
var y:Typ2 = (a="x", b=0)

x["hello"] = 44
y = ("hello",44)
cassert x==y

let Matrix8x8 = (
  ,data:[8][8]u16 = _
  ,setter = fun(ref self, x:int(0,7), y:int(0,7), v:u16) {
    self.data[x][y] = v
  } ++ fun(ref self, x:int(0,7), v:u16) {
    for ent in ref data[x] {
      ent = v
    }
  } ++ fun(ref self) { // default initialization
    for ent in ref data {
      ent = 0
    }
  }
)

let m:Matrix8x8 = _
cassert m.data[0][3] == 0

m[1,2] = 100
cassert m.data[1][2] == 100
m[1] = 3
cassert m.data[1][2] == 3
m[4][5] = 33
cassert m.data[4][5] == 33

m[1] = 40
cassert m[1] == (3,40,3,3,3,3,3,3)

let Matrix2x2 = (
  ,data:[2][2]u16 = _
  ,getter = fun(ref self, x:int(0,2), y:int(0,2)) {
    self.data[x][y] + 1
  }

)

let n:Matrix2x2 = _
n.data[0][1] = 2      // default setter

cassert n[0][1] == 3  // getter does + 1

let My_2_elem = (
  ,data:[2]string = _
  ,setter = proc(ref self, x:uint(0..<2), v:string) {
    self.data[x] = v
  } ++ proc(ref self, v:My_2_elem) {
    self.data = v.data
    } ++ proc(ref self) { // default _ assignment
      self.data = _
    }
  ,getter = fun(self)         { self.data    }
         ++ fun(self, i:uint) { self.data[i] }
)

var v:My_2_elem = _
var x:My_2_elem = _

v = (x=0, "hello")
v[1] = "world"

cassert v[0] == "hello"
cassert v == ("hello", "world")  // not

let z = v
cassert z !equals v   // v has v.data, z does not

let some_obj = (
  ,a1:string
  ,a2 = (
    ,_val:u32 = _                               // hidden field

    ,getter=fun(self) { self._val + 100 }
    ,setter=proc(ref self, x) { self._val = x+1 }
  )
  ,setter = proc(ref self, a,b){                  // setter
    self.a1      = a
    self.a2._val = b
  }
)

var x:some_obj = ("hello", 3)

assert x.a1 == "hello"
assert x.a2 == 103
x.a2 = 5

let showcase = (
  ,v:int = _
  ,getter = fun(self)->(_:string) where self.i>10 {
    format("this is a big {} number", self.v)
  } ++ fun(self)->(_:int) {
    self.v
  }
)

var s:showcase = _
s.v = 3
let r2:int    = s // OK

s.v = 100
let r3:string = s // OK
cassert r3 == "this is a bit 100 number"

let my_obj = (
  ,val:u32 = _
  ,getter = fun(self)->(_:string ){ string(self.val) }
       ++ fun(self)->(_:bool){ self.val != 0    }
       ++ fun(self)->(_:int    ){ self.val         }
)

var obj1::[attr1] = (
  ,data:int = _
  ,setter = fun(ref self, v) {
    if v.[attr2] {
      self.data.[attr3] = 33
    }
    cassert self.[attr1]
  }
)

let fint:int = _
cassert fint == 0

var fbool:bool = _
cassert fbool == 0

let Tup = (
  ,v:string = _  // default to empty
  ,setter = fun(ref self) { // no args, default setter for _
     cassert self.v == ""
     self.v = "empty33"
  } ++ fun(ref self, v) {
     self.v = v
  }
)

var x:Tup = _
cassert x.v == "empty33"

x = "Padua"
cassert x.v == "Padua"

var y = Tup()
cassert y.v == "empty33"

y = "ucsc"
cassert y.v == "ucsc"

var my_arr = (
  ,vector:[16]u8 = 0
  ,getter = fun(self, idx:u4) {
     self.vector[idx]
  }
  ,setter = proc(ref self, idx:u4, val:u8) {
     self.vector[idx] = val
  } ++ proc(ref self) {
     // default constructor declaration
  }
)

my_arr[3] = 300           // calls setter
my_arr.3  = 300           // calls setter
cassert my_add[3] == 300  // calls getter
cassert my_add.3  == 300  // calls getter

let Point = (
  ,priv_x:int:[private] = 0
  ,priv_y:int:[private] = 0

  ,setter = proc(ref self, x:int, y:int) {
    self.priv_x = x
    self.priv_y = y
  }

  ,getter = proc(self, idx:string) {
    match idx {
     == 'x' { self.priv_x }
     == 'y' { self.priv_y }
    }
  }
)

let p:Point = (1,2)

cassert p['x'] == 1 and p['y'] == 2

let t=(
  ,v:string = _
  ,setter = proc(ref self) { self.v = a }
  ,lt = fun(self,other)->(_:bool){ self.v  < other.v }
  ,eq = fun(self,other)            { self.v == other.v } // infer return
)

var m1:t = 10
var m2:t = 4
assert m1 < m2 and !(m1==m2)
assert m1 <= m2 and m1 != m2 and m2 > m1 and m2 >= m1

let t1=(
  ,long_name:string = "foo"
  ,b=33
)
let t2=(
  ,b=33
  ,long_name:string = "foo"
)
let t3=(
  ,33
  ,long_name:string = "foo"
)

cassert t1==t2
cassert t1 !equals t3

cassert (a==b) == ((a in b) and (b in a))
cassert a equals b

let t1=(
  ,long_name:string = "foo"
  ,b=33
)
let t2=(
  ,xx_a=33
  ,yy_b = "foo"
  ,eq = fun(self, o:t1) {
    return self.xx_a == o.b and self.xx_y == o.long_name
  } ++ fun(self, o:t2) {
    return self.xx_a == o.xx_a and self.xx_y == o.xx_y
  }
)

cassert t1==t2 and t2==t1

let cfg = __read_json()

let ext = if cfg.foo.bar == 3 {
   foo
}else{
   bar
}

let __my_typed_cpp:fun(a,b)->(e) = _

let Animal = (
  ,legs:int = _
  ,name= "unnamed"
  ,say_name = fun() { puts name }
)

let Dog = Animal ++ (
  ,setter = proc(ref self) { self.legs = 4 }
  ,bark = fun() { puts "bark bark" }
)

let Bird = Animal ++ (
  ,seeds_eaten:int = _

  ,setter = proc(ref self)  { self.legs = 2 }
      ++ proc(ref self, a:Animal)    { self.legs = 2 ; name = "bird animal" }
  ,eat_seeds = proc(ref self, n) { self.seeds_eaten += n }
)

let Greyhound = Dog ++ ( // also extends Dog
  ,race = fun() { puts "running fast" }
)

var a:Animal = _
var b:Bird = _
var d:Dog = _

b = a // OK, explicit setter in Bird for Animal

a = d // OK, 'd does a' is true
a = b // OK, 'Bird does Animal' is true

var a_vec:[]Animal = _
var b_vec:[]Bird = _
var d_vec:[]Dog = _

a_vec[0] = d:Dog    // OK
a_vec[1] = b:Bird   // OK

d_vec[0] = d:Dog        // OK  'd does d'
d_vec[0] = g:Greyhound  // OK  'g does d'
d_vec[0] = b:Bird       // Compile error
d_vec[0] = a:Animal     // Compile error

b_vec[0] = d:Dog        // OK, explicit conversion
b_vec[0] = g:Greyhound  // OK, explicit conversion
b_vec[0] = b:Bird       // OK, 'b does b'
b_vec[0] = a:Animal     // OK, explicit conversion

let do_animal_vec = fun(a_vec:[]Animal)->(r:[]Animal) {
  r = a_vec
  r[0] = d:Dog  // OK `d does r[0]`
}

var x = do_animal_vec(b_vec:[]Bird) // OK
assert x does _:[]Animal  // not :[]Bird

let Age = (
  ,age:int = _
)
let Weight = (
  ,weight:int = _
)

assert Age !does Weight

var a:Age = 3
assert a == a.age == a.0 == 3

var w:Weight = 100


let f = fun(a,b) -> (r:int) { r = xx(a) + xx(b) }

let f1 = fun<T:Some_type_class>(a:T,b:T) -> (r:int) { r = xx(a) + xx(b) }

let fa_t:fun(a:Animal)->() = _
let fd_t:fun(d:Dog)->() = _

let call_animal = fun(a:Animal)->() {
   puts a.name // OK
}
let call_dog:fd_t = fun(d:Dog)->() {    // OK to add type in lhs
   d.bark()    // OK
}

let f_a = fun(fa:fa_t) { 
  var a:Animal = _
  var d:Dog = _
  fa(a)  // OK
  fa(d)  // OK, `d does Animal` is true
}
f_a(call_animal) // OK

let f_d = fun(fd:fd_t) { 
  var a:Animal = _
  var d:Dog = _
  fd(d)  // OK
}
f_d(call_animal) // OK, `fd_t does call_animal` is true
f_d(call_dog)    // OK

let m = fun(a:int,...x:(_:string,c:int,d), y:int)->() { 
  assert a == 1
  assert x.0 == "here"
  assert x.1 == 2 == x.c
  assert y == 3
  if d does int { // inferred type
    assert d == 33
  }else{
    assert d == "x"
  }
}

m(1,"here",2,"x",3)         // OK
m(a=1,"here",2,"x",3)       // OK
m(a=1,"here",c=2,"x",3)     // OK
m(a=1,"here",c=2,33,y=3)    // OK


let base = (
  ,fun1 = fun() { 1 }         // catch all
  ,fun2 = fun() { 2 }         // catch all
  ,fun3 = fun() { 3 }         // catch all
)
let ext = base ++ (
  ,fun1 =   fun (a,b){ 4 }  // overwrite allowed with extends
  ,fun2 ++= fun (a,b){ 5 }  // append
  ,fun2 ++= fun ()   { 6 }  // append
  ,fun3 =   fun(a,b) { 7 } ++ base.fun3 // prepend
  ,fun3 =   fun()    { 8 } ++ base.fun3 // prepend
)

var t:ext = _

// t.fun1 only has ext.fun1
assert t.fun1(a=1,b=2) == 4

// t.fun2 has base.fun2 and then ext.fun2
assert t.fun2(1,2) == 5  // EXACT match of arguments has higher priority
assert t.fun2() == 2     // base.fun2 catches all ahead of ext.fun2

// t.fun3 has ext.fun3 and then base.fun3
assert t.fun3(1,2) == 7  // EXACT match of arguments has higher priority
assert t.fun3() == 8     // ext.fun3 catches all ahead of ext.fun3

let x = base ++ (
  ,fun1 = fun() { return base.fun1() + 100 }
)

var fun_list = fun(a,b){ a+b}
fun_list ++= fun(a,b,c){ a+b+c }
fun_list ++= fun(a,b,c,d){ a+b+c+d }

assert fun_list.[size] == 3    // 3 lambda entries in fun_list

assert fun_list(1,2) == 3
assert fun_list(1,2,4) == 7
assert fun_list(1,2,4,5) == 12


fun_list ++= fun(a,b){ 100}
assert fun_list(1,2) == 3

fun_list = fun(a,b){ 200} ++ fun_list
assert fun_list(1,2) == 200

var f1 = fun(a,b){ a+b+100 }
  f1 ++= fun(x,y){ x+y+200 }

assert f1(a=1,b=2) == 103
assert f1(x=1,y=2) == 203
assert f1(  1,  2) == 103  // first in list

var fo = fun(a:int,b:string)->(_:bool)  { true    }
  fo ++= fun(a:int,b:int   )->(_:bool)  { false   }
  fo ++= fun(a:int,b:int   )->(_:string){ "hello" }

let a = fo(3,hello)
assert a == true

let b = fo(3,300)        // first in list return bool
assert b == false

let c:string = fo(3,300)
assert c == "hello"

var f1 = fun(a,b)      where a >  40 { b+100    }
      ++ fun(a,b)->(x) where x > 300 { b+200    } // output x
      ++ fun(a,b)->(a) where a >  20 { b+300    } // input a
      ++ fun(a,b)->(x) where x >  10 { b+400    } // output x
      ++ fun(a,b)                    { a+b+1000 } // default

var fun_manual = fun(a,b){  // equivalent but not as maintenable
  if a>40 {
    return b+100
  }
  let x = b + 200
  if x>300 {
    return (x=x)
  }
  if a>20 {
    return b+300
  }
  let tmp = a + b
  if tmp >10 {
    return (a=tmp)
  }
  return a+b+1000
}

test "check equiv" {
  for a in -100..=100 {
    for b in -100..=100 {
      assert f1(a,b) == fun_manual(a,b)
    }
  }
}

let Param_type = fun(a) { return (xx:a = _) }

let x:Param_type(string) = (xx="hello")
let x:Param_type(int)    = (xx=130)

let Animal = (
  ,speak:fun(self) = _
)
let Cat: Animal = (
  ,speak = fun(self) { puts "meaow" }
)
let Bird: Animal = (
  ,speak = fun(self) { puts "pio pio" }
)

let smallest = fun(...a) {
  let x = a[0]
  for i in a[1..] {
    x = i when i < x
  }
  return x
}

let speak = fun(a:Bird) { puts "pio pio"  } 
         ++ fun(a:Cat) { puts "meaow" }

let Type1 = (
  ,setter = fun(ref self, a:int) {  }
)
let a:Type1 = 33

let Say_mixin = (
  ,say = fun(s) { puts s }
)

let Say_hi_mixin = (
  ,say_hi  = fun() {self.say("hi {}", self.name) }
  ,say_bye = fun() {self.say("bye {}", self.name) }
)

let User = (
  ,name:string = _
  ,setter = proc(ref self, n:string) { self.name = n }
)

let Mixing_all = Say_mixin ++ Say_hi_mixin ++ User

var a:Mixing_all="Julius Caesar"
a.say_hi()

let Int1 = (
  ,var counter:int:[private] = 0
  ,add = proc(ref self, v) { self.counter += v }
  ,get = fun(self) -> (_:int) { self.counter }
  ,api_pending: proc(ref self, x:int) -> (o:string) = _
)

let Int2 = (
  ,var counter:int:[private] = 0
  ,accumulate = proc(ref self, v) { self.counter += v ; return self.counter }
  ,api_pending:proc(ref self, x:string) -> (o:string) = _
)

let Combined = (...Int1, ...Int2
  ,api_pending = proc(ref self, x:int) -> (o:string) {
    self.add(x)
    string(self.accumulate(self.get()))
  }
)

let Interface = (
  ,let add:fun(ref self, x) = _ // nil or undefined method
  ,let sub = fun(ref self,x ) { self.add(-x) }
)


let My_obj = (
  ,val1:u8 = 0
  ,let add = fun(ref self, x) { self.val += x }
) ++ Interface                  // OK, but not recommended

let My_obj2 = (
  ,...Interface                 // recommended
  ,val1:u8 = 0
  ,let add = fun(ref self, x) { self.val += x }
)
cassert My_obj equals My_obj2   // same behavioir no defined overlap fiels

let xx:My_obj = _               // default initialization

cassert xx.val1 == 0
xx.add(3)
cassert xx.val1 == 3
xx.sub(2)
cassert xx.val1 == 1

let exclude = fun(o,...a) {
  let new_tup = ()
  for (key,idx,e) in zip(o.keys(),o.enumerate()) {
    // create single tupe and append to preserve key and position order
    let sing_tup = ()
    sing_tup[key] = e
    new_tup ++= sing_tup unless key in o
  }
  new_tup
}

let Shape = (
  ,name:string = _
  ,area:fun (self )->(_:i32)  = _            // undefined 
  ,increase_size:proc(ref self, x:i12) = _  // undefined 

  ,setter=proc(ref self, name ) { self.name = name } // implemented, use =
  ,say_name=fun(self) { puts "name:{}", name }
)

let Circle = (
  ,...exclude(Shape,'setter')
  
  ,setter        = proc(ref self) { Circle.setter(this, "circle") }
  ,increase_size = proc(ref self, x:i12) { self.rad *= x }
  ,rad:i32       = _
  ,area = fun(self) -> (_:i32) {
     let pi = import("math").pi
     return pi * self.rad * self.rad
  }
):Shape  // extra check that the exclude did not remove too many fields

let rotate = fun(a) where a has 'x', a has 'y' and_then a.y!=30 {
  var r = a
  r.x = a.y
  r.y = a.x
  return r
}

reg mem:[] = 0
mem[3]   = something // async memory
var array:[] = _
array[3] = something // array no cross cycles persistence

var index:u7 = _
var index2:u6 = _

array[index] = something
some_result  = array[index2+3]

reg mem1:[16]i8 = 3   // mem 16bit memory initialized to 3 with type i8
reg mem2:[16]i8 = _   // mem 16bit memory initialized to 0 with type i8
var mem3:[] = 0sb?        // array infer size and type, 0sb? initialized
var mem4:[13] = 0         // array 13 entries size, initialized to zero

x1 = array[first..<last]  // from first to last, last not included
x2 = array[first..=last]  // from first to last, last included
x3 = array[first..+size]  // from first to first+size, first+size. not included

a[3][4] = 1

var b:[4][8]u8 = 13

assert b[2][7] == 13

    var mem1:[4][8]u5 = 0
    var reset_value:[3][8]u5:[comptime] = _ // only used during reset
    for i in 0..<3 {
      for j in 0..<8 {
        reset_value[i][j] = j
      }
    }
    reg mem2 = reset_value   // infer async mem u5[3][8]

    var mem = ( 
      ,(u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0))
      ,(u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0))
      ,(u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0))
      ,(u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0), u5(0))
    )
    reg mem2 = ( 
      ,(u5(0), u5(1), u5(2), u5(3), u5(4), u5(5), u5(6), u5(7))
      ,(u5(0), u5(1), u5(2), u5(3), u5(4), u5(5), u5(6), u5(7))
      ,(u5(0), u5(1), u5(2), u5(3), u5(4), u5(5), u5(6), u5(7))
    )

    reg rf:[32]i64 = 0sb?   // random initialized

    reg a:(addr1:u5, addr2:u5) = (0,0)

    data_rs1 = rf[a.addr1]
    data_rs2 = rf[a.addr2]

    a = (insn[8..=11], insn[0..=4])

    var rf:[32]i64 = 0sb?

    reg a:(data1:i64, data2:i64) = _

    data_rs1 = a.data1
    data_rs2 = a.data2

    a = (rf[insn[8..=11]], rf[insn[0..=4]])

// A 2rd+1wr memory (RF type)

mem.addr    = (raddr0, raddr1, wraddr)
mem.bits    = 4
mem.size    = 16
mem.clock   = my_clock
mem.din     = (0, 0, din0)
mem.enable  = (1, 1, we0)

mem.fwd     = false
mem.latency = (1, 1, 1)
mem.wensize = 1 // we bit (no write mask)
mem.rdport  = (-1,1,0) // 0 WR, !=0 -> RD

res =#[..] __memory(mem)

q0 = res.0
q1 = res.1


var d2:[2][2] = ((1,2),(3,4))
assert d2[0][0] == 1 and d2[0][1] == 2 and d2[1][0] == 3 and d2[1][1] == 4

assert d2[0] == (1,2) and d2[1] == (2,3)

let flatten = fun(...arr) {
  var res = 0
  for i in arr {
    res ++= i
  }
  return res
}

assert flatten(d2) == (1,2,3,4)
assert flatten((((1),2),3),4) == (1,2,3,4)

var x1:[2]u3 = (0,1)
assert x1[0] == 0 and x1[1] == 1

var X=enum(
  ,t1 = 0 // sequential enum, not one hot enum (explicit assign)
  ,t2
  ,t3
)

var x2:[X]u3 = _
x2[X.t1] = 0
x2[X.t2] = 1

var x3:[-8..<7]u3 = _  // accept signed values

var x4:[100..<132]u3 = _

assert x4[100] == 0

reg r_ver = 0sb?

reg r = _
var v = _

assert v == 0 and r == 0

assert !(r_ver != 0)    // it will randomly fail
assert !(r_ver == 0)    // it will randomly fail
assert !(r_ver != 0sb?) // it will randomly fail
assert !(r_ver == 0sb?) // it will randomly fail

var arr:[] = (0,1,2,3,4,5,6,7)

always assert arr[0] == 0 and arr[7] == 7  // may FAIL during reset

reg mem:[] = (0,1,2,3,4,5,6,7)

always assert mem[7] == 7                  // may FAIL during reset
always assert mem[7] == 7 unless mem.reset // OK
assert mem[7] == 7                         // OK, not checked during reset

cassert (a=1) in (1,a=1,3)
cassert (a=1) !does (1,a=1,3)

let f = fun(a) { puts "{}",a }
let g = fun(long, short) { puts "{}",long }

f(a=1)             // OK
f(1)               // OK

g(long=1, short=1) // OK
let long=1
g(long, short=1)   // OK
let short=1
g(long, short)     // OK



    optimize sel==1 or sel==2 or sel==4 // not needed. match sets it
    match sel {
      == 0b001 { f = i0 }
      == 0b010 { f = i2 }
      == 0b100 { f = i3 }
    }

    f = (sel[0] & i0)
      | (sel[1] & i1)
      | (sel[2] & i2)



    optimize a != 0


    if (1 + a) != 1 { // always false
      out = 1
    }else{
      out = 3
    }

    optimize b != 3 
    // array = (1,2,3,4,5,6,7,8)
    res = array[b]

let f1 = fun() { 1 }

let tup = (
  ,f1 = fun() { 2 }

  ,code = fun() {
     assert self.f1() == 2
     assert f1() == 1
  }
)

    var x_s = 10

    let call_captured = fun[x_s]() {
      return fun[x_s]() {
        assert x_s == 10
        return x_s
      }
    }

    test "capture test" {
      let tst = fun() {
        var x_s = 20   // not variable shadowing because fun scope

        let x1 = call_captured()
        assert x1 == 10

        x_s = 30;

        let x2 = call_captured()
        assert x2 == 10
      }
      tst // call the test
    }



    let j = 1
    let b = fun[j](x:i32)-> :i32 {
      return x+j
    }

    assert b(1) == 2

    test "closure with tuple" {
      var a: i32 = 1
      a += 1

      var addX = (
        ,a: i32 = a                        // copy value, runtime or comptime
        ,getter = fun(self, x: i32) {
          return x + self.a
        }
      )

      a += 100;

      assert addX(2) == 4
    }

    test "plain closure" {
      var a:i32 = 1
      a += 1

      let addX = fun[a](x: i32) { // Same behaviour as closure with tuple
        return x + a
      }

      a += 100;

      assert addX(2) == 4
    }



var x = 3

let f1 = fun[x]()->(_:int){
   assert x == 3
   return 200
}
let f2 = fun()->(_:int){
   var x = _    // OK, no captures 'x' variable
   x = 100
   return x
}

var x = 3
var y = 10

let fun2 = fun[y]()->(_:int){
  var x  = 200
  return y + x
}
x = 1000
assert fun2() == 203

assert 0 == (0)  // OK, same as assert( 0 == (0) )
assert(0 == 0)   // OK

asssert(2 in (1,2)) // OK

let X_t = (
  ,i1 = (
    ,i1_field:u32 = 1
    ,i2_field:u32 = 2
    ,setter = proc(ref self, a) {
       self.i1_field = a
    }
  )
  ,i2 = (
    ,i1_field:i32 = 11
    ,setter = proc(ref self, a) {
       self.i1_field = a
    }
  )
)

var top = (
  ,setter = proc(ref self) {
    var x:X_t = _
    assert x.i1.i1_field == 1
    assert x.i1.i2_field == 2
    assert x.i2.i1_field == 11

    x.i1 = 400

    assert x.i1.i1_field == 400
    assert x.i1.i2_field == 2
    assert x.i2.i1_field == 11

    x.i2 = 1000

    assert x.i1.i1_field == 400
    assert x.i1.i2_field == 2
    assert x.i2.i1_field == 1000
  }
)

assert !(0sb? == 0)
assert !(0sb? != 0)
assert !(0sb? == 0sb?)
assert !(0sb? != 0sb?)

var x = 0sb10?
let str = __to_string(x) // only works for compile time constants
assert x == "0sb10?"

let s:string="hell"
for (idx,i) in s.enumerate() {
  let v = match idx {
   == 0 { "h" }
   == 1 { "e" }
   == 2 { "l" }
   == 3 { "l" }
  }
  assert v == i
}

let t = (1,2,3)
for (idx,i) in t.enumerate() {
  let v = match idx {
   == 0 { 1 }
   == 1 { 2 }
   == 2 { 3 }
  }
  assert v == i
}

let r=2..<5
for (idx,i) in r.enumerate() {
  let v = match idx {
   == 0 { 2 }
   == 1 { 3 }
   == 2 { 4 }
  }
  assert v == i
}

let r2=4..=2 step -1
assert r2 == (4,3,2)
for (idx,i) in r2.enumerate() {
  let v = match idx {
   == 0 { 4 }
   == 1 { 3 }
   == 2 { 2 }
  }
  assert v == r2[i]
}

for i in 2..<5 {
  let ri = 2+(4-i) // reverse index
  // 2 == (2..<5).trailing_one
  // 4 == (2..<5).leading_one
  let v = match idx {
   == 0 { 4 }
   == 1 { 3 }
   == 2 { 2 }
  }
  assert v == ri
}

for (idx,i) in enumerate(123) {
  assert i == 123 and idx==0
}

let v = 0xF0

assert v@[0] == 0
assert v@[4] == 1       // unsigned output
assert v@sext[4] == -1  // signed output

assert v@[3..=4] == 0b010 == v@[3,4]
assert v@[4..=3 step -1] == 0b010
assert v@[4,3] == v@[3,4] == 0b010

let tmp1 = (v@[4], v@[3])@[..]  // typecast from 
let tmp2 = (v@[3], v@[4])@[..]
let tmp3 = v@[3,4]
assert tmp1 == 0b01
assert tmp2 == 0b100
assert tmp3 == 0b10

let tmp1s = (v@sext[4], v@sext[3])@[..]  // typecast from 
let tmp2s = (v@sext[3], v@sext[4])@[..]
let tmp3s = v@[4,3]
assert tmp1s == 0b01
assert tmp2s == 0b10
assert tmp3s == 0b10

let tmp1ss = (v@sext[4], v@sext[3])@sext[..]  // typecast from 
let tmp2ss = (v@sext[3], v@sext[4])@sext[..]
let tmp3ss = v@sext[3,4]
assert tmp1ss == 0b01  ==  1
assert tmp2ss == 0sb10 == -2
assert tmp3ss == 0sb10 == -2 == v@sext[4,3]

let reverse = fun(x:uint)->(total:uint) {
  for i in 0..<x.__bits {
    total <<= 1
    total  |= x@[i]
  }
}
assert reverse(0b10110) == 0b01101

let args = fun(x) { puts "args:{}", b ; 1}
let here = fun()  { puts "here" ; 3}

let call_now   = fun(f:fun){ return f() } 
let call_defer = fun(f:fun){ return f   } 

let x0 = call_now(here)          // prints "here"
let x1 = call_defer(here)        // nothing printed
assert x0  == 3                  // nothing printed
assert x1  == 3                  // nothing printed

let x2 = call_now(ref here)      // prints "here"
let x3 = call_defer(ref here)    // nothing printed
let x4 = call_defer(ref args)    // nothing printed
assert x2  == 3                  // nothing printed
assert x3()  == 3                // prints "here"
assert x4("xx") == 1             // prints "args:xx"


if if x == 3 { true }else{ false } {
  puts "x is 3"
}

let v = (3)--3
assert v == 6

var a = 1
var b = 2

cassert a==1 and b==2
b::[defer] = a
cassert a==1 and b==2

cassert b.[defer] == 1



let max_gap_count = fun(nums) {
  let max  = import("std").max
  let sort = import("std").sort
  let adjacent_transform = fun(a,num,f) {
    var res:[] = _
    for i in 0..<a.length step num {
      res ++= f(a[i..+num])
    }
    return res
  }
  let count = fun(a,b) {
    var r = 0
    for i in a {
      r += 1 when i == b
    }
    return r
  }

  return numbers
     |> sort(fun(a,b) { a<b })
     |> adjacent_transform(num=2, fun(a,b) { a-b } )
     |> fun(a) { count(a, a.max) }
}



let add = fun(a,b) { a + b }            // OK, no constrains
let add = fun<T:int>(a:T,b:T) { a + b } // constrain both to have same type



let Shape = (
  ,name:fun(self)->(_:string)    = _
  ,area:fun(self)->(_:Float)     = _  // NOTE: Pyrope does not have float type
  ,perimeter:fun(self)->(_:Float)= _
)

let Rectangle:(...Shape,...OtherAPI) = (...some_code_here)
let Circle:Shape = (...some_code_here) 

let print_share_info = fun(s:Shape) { }



let AnObject = (
  ,v:i32 = _
)

let f1 = proc(ref self:AnObject) -> :i32 { // unnamed output tuple
  let res = self.v
  self.v += 1
  return res
}
let f2 = fun(self:AnObject) -> :i32 {
  return self.v
}

let AnObject = (
  ,v:i32 = _
  ,f1 = proc(ref self) -> (res:i32) {
    res = self.v
    self.v += 1
  }
  ,f2 = fun(self) -> :i32 { self.v }
)



    let Person = (name:string=_, age:u32=_)
    var a = (one:Person, two:Person)

    x = 'one'
    y = 'two'
    a[x].age = 10
    a[y].age = 10

let telescope_unit = fun(a:u32,b:u32,start:bool) -> (res:u32) {

  reg result_done = 0
  reg result_flop = 0

  if result_done {
    res = result_flop
  }

  reg int_done = _
  reg int_flop = _
  reg int_b = _

  if int_done {  // pending work (2 cycle op, can not telescope)
    result_flop = int_flop-int_b
    result_done = int_done
    int_flop = a+1
    int_b    = b
    int_done = start
  }else{          // no pending work from before (telescoping is allowed)
    if b == 0 {
      result_flop = a+1
      result_done = start
    }else{
      result_flop = int_flop-int_b
      int_flop = a+1
      int_b    = b
      int_done = start
    }
  }
}

 let res1 =#[1,2] telescope_unit(a,b,start)

 if res1? {
   puts "{}-{}+1 is {}", a, b, res1.res  // incorrect reference to a
 }

 let res1 =#[1,2] telescope_unit(a,b,start)

 yield res1? // wait for condition to happen
 assert res1?

 // code executed 1 or 2 cycles after telescope_unit is called
 puts "{}-{}+1 is {}", a, b, res1.res

// implicit start/end (starts when called)
let telescope_unit3 = fun(a:u32,b:u32) -> (_:u32) {

  {
    let tmp = a+1
  } #>one_pipe[lat=1] {
    if b == 0 {
      return tmp
    }
    let tmp2 = tmp-b
  } #> {
    return tmp2
  }
}

 let res2 =#[1,2] telescope_unit3(a,b,start)

 if res2? { // code executed 1 or 2 cycles after telescope_unit is called
   puts "{}-{}+1 is {}", a, b, res2
 }











while some_condition {

  step   // next cycle starts here
}

    let x = 3 + 1
    var z = 4
    `foo x` = x + z + 2





    let a:u2:[foo] = b:u1:[bar]

    x:u2:[foo] = y:u1:[bar]



    x = 3
    a = (b=2, x=x+1, y=self.b+1)







    x = tup[1].foo[xx]
    tup[4].foo[yy] = y

    z = (foo=(bar=1))



    var a = (b=2, let x=1+1)





    var a = (2, 1+1)
    let x = a ++ (c=3) ++ 1





    a::[f=3,b] = 1
    x = (y::[z=7]=2, 4)



    var x = (let z=x::[!y], 4::[foo])
    let y = a::[f==3,b] + 1





    let d::[debug] = 3

    var a = d + 100

    cassert a.[debug]  // debug is sticky



let foo::[attr1=2] = 3

var foo2 = foo
cassert foo2.[attr1] == 2

let foo3 = foo@[..]
cassert foo3 !has _::[attr1]

var xx = 4
xx::[attr2=5] = 1

let xx2 = xx
cassert xx2.[attr2] == 5
cassert xx2 has _::[attr2]

let xx3 = xx + 0
cassert xx3 !has _::[attr2]

    foo@[1,2] = xx
    yy = foo@[5] + xx@[1..<4]





    let t1 = foo@sext[..=4]
    let t2 = foo@|[..=4]
    let t3 = foo@&[..=4]
    let t4 = foo@^[..=4]
    let t5 = foo@+[..=4]



    let foo = 3
    let bar = 300
    let b = __plus(1,2,foo,bar)



    LNAST("let", ("ref", "x"), ("const", "5"))



















    a = b and_then c and_then (d or e)



    a = b or_else c or_else (d and e)



let tup=(1,2,3)
let ran=1..<5
let enu = enum(a,b=(x,y),c)

cassert 2 in tup
cassert 3 in ran
cassert enu.b.x in enu.b

    c = a in b
    d = a !in b



























    var total=3
    if var x=3; x<3 {
      total+=x
    }elif var z=3; z<4 {
      total+=x+z
    }

    var total=3
    {
      var x=3
      if x<3 {
        total+=x
      }else{
        var z=3
        if z<4 {
          total+=x+z
        }
      }
    }



    if var x=a ; x<3 {
      t = 100+x               // z not in scope
    }elif var z = x+c ; z>5 {
      t = 200+z+x             // z and x in scope
    }








    unique if a<3 {
      y = 10
    }elif a>40 {  // not allowed to do 'elif var z=40; a>z'
      y = 20+x
    }

    let tmp1 = a<3
    let tmp2 = a>40
    let tmp3 = 1<<(tmp1,tmp2)
    optimize tmp3@+[..]<=1        // at most one bit set

    if tmp1 {
      y = 10
    }elif tmp2 {
      y = 20+x
    }



    var z = 0
    match x {
     == 3 { z = 1 }
     in 4..<6 { z = 2 }
    }

    match x {
     <  5 { z = 1 }
     else { z = 3 }
    }



    if var x=3; x<4 {
      cassert x==3
    }
    while var z=1; x {
      x -= z
    }
    var z=0
    match var x=2 ; z+x {
      == 2 { cassert true  }
      != 7 { cassert true  }
      else { cassert false }
    }



    loop {
      i += 1
      break when i==3
    }



    while var i=0 ; i!=3 {
      i += 1
    }



    for (index,key,value) in enumerate(key(tup)) {
      mycall(value,index,key)
    }

    for value in ref tup {
      mycall(value)
      value = 0
    }





    let num = 1
    let color = "blue"
    let extension = "s"

    txt = "I have {num:d} {color} potato{extension}"



    x = fcall(a,b=3,foo,1+2)



let prp = import("prp")
cassert prp.plus(1,2,3) == 6

let plus = fun(...a:int)->(_:int) {
  var r = 0
  for e in a {
    r += e
  }
  r
}

let x = (1,2,23)

cassert p.len(x) == 3

let len = fun(x) { x.[size] }

let x = (1,2,3)

cassert x.map(fun(i){ i+1 }) == (2,3,4)

let map = fun<T>(f:fun(a:T),...x:[]T) {
  return f(e) for e in x
}

cassert (1,2,3).filter(fun(i){ i!=2 }) == (1,3)

let filter = fun<T>(f:fun(a:T)->(_:Bool),...x:[]T) {
  return e for e in x if not f(e)
}

cassrt (1,2,3).reduce(prp.plus) == 6

let reduce = fun(op:fun<T>(a:T,b:T)->(_:T), ...x) {
  return x when x.[size] <= 1

  var res = x[0]
  for i in x[1..] {
    res = op(res, i)
  }
  return res
}

