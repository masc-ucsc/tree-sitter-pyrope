
find_one = (

  ,set = {|(x)->(self)|
    self = pick(x)
  }

  ,pick = {|(x:u4)->(pos:u2,found:boolean)|
    ret match x {
      == 0b1??? { (3  ,true ) }
      == 0b01?? { (2  ,true ) }
      == 0b001? { (1  ,true ) }
      == 0b0001 { (0  ,true ) }
      == 0b0000 { (0b?,false) }
    }
  }
  ,pick = {|(x:u3)->(pos:u2,found:boolean)|
    match x {
      == 0b1?? { ret 2,true }
      == 0b01? { ret 1,true }
      == 0b001 { ret 0,true }
      == 0b000 { ret 0b?,false }
    }
  }
  ,pick = {|(x:u2)->(pos:u2,found:boolean)|
    ret match x {
      == 0b1? { (1  ,true ) }
      == 0b01 { (0  ,true ) }
      == 0b00 { (0b?,false) }
    }
  }
  ,pick = {|(x:u1)->(pos:u1,found:boolean)|
    ret 0, x
  }

  ,pick = {|(x)->(pos,found:boolean)|
    let list = for i in 0..<x.__ubits by 4 {
      cont pick(x[i..+4])
    }

    for e,index in list {
      continue unless e.found
      ret (pos=(i*4) | e.pos, found=true)
    }

    ret (pos=0,found=false)
  }
)

freelist = (
  ,top
  ,empty:bool

  ,pop = {|(self)->(self)|
    let f = find_one(self.bitmask)

    self.empty = !f.found
    self.top   =  f.pos

    self.bitmask@[f.pos] = false
  }

  ,push = {|(self, free)->(self)|
    assert !self.bitmask@[free]

    if empty {
      self.top = free
      return
    }

    self.bitmask@[free] = true
  }

  ,mask_push = {|(self, mask)->(self)|

    assert 0 == (self.bitmask & mask)

    self.bitmask |= mask
    if empty {
      let f = find_one(mask)

      self.empty = !f.found
      self.top   =  f.pos

      self.bitmask@[f.pos] = false
    }
  }

  ,set = {|(self,initmask)->(self)|
     self.bitmask = initmask
     pop() // To populate top
  }
)
