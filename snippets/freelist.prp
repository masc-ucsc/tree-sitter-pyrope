
find_one = (

  ,set = {|(x)->(self)|
    self = pick(x)
  }

  ,pick = {|(x:u4)->(pos:u2,found:boolean)|
    return match x {
      == 0b1??? { return 3,true }
      == 0b01?? { return 2,true }
      == 0b001? { return 1,true }
      == 0b0001 { return 0,true }
      == 0b0000 { return 0b?,false }
    }
  }
  ,pick = {|(x:u3)->(pos:u2,found:boolean)|
    return match x {
      == 0b1?? { return 2,true }
      == 0b01? { return 1,true }
      == 0b001 { return 0,true }
      == 0b000 { return 0b?,false }
    }
  }
  ,pick = {|(x:u2)->(pos:u2,found:boolean)|
    return match x {
      == 0b1? { return 1,true }
      == 0b01 { return 0,true }
      == 0b00 { return 0b?,false }
    }
  }
  ,pick = {|(x:u1)->(pos:u1,found:boolean)|
    return 0, x
  }

  ,pick = {|(x)->(pos,found:boolean)|
    let list = for i in 0..<x.__ubits by 4 {
      continue pick(x[i..+4])
    }

    for e,index in list {
      continue unless e.found
      return (pos=(i*4) | e.pos, found=true)
    }

    return (pos=0,found=false)
  }
)

freelist = (
  ,top
  ,empty:bool

  ,pop = {|(self)->(self)|
    let f = find_one(self.bitmask)

    self.empty = !f.found
    self.top   =  f.pos

    self.bitmask@[f.pos] = false
  }

  ,push = {|(self, free)->(self)|
    assert !self.bitmask@[free]

    if empty {
      self.top = free
      return
    }

    self.bitmask@[free] = true
  }

  ,mask_push = {|(self, mask)->(self)|

    assert (self.bitmask & mask) == 0

    self.bitmask |= mask
    if empty {
      let f = find_one(mask)

      self.empty = !f.found
      self.top   =  f.pos

      self.bitmask@[f.pos] = false
    }
  }

  ,set = {|(self,initmask)->(self)|
     self.bitmask = initmask
     pop() // To populate top
  }
)
